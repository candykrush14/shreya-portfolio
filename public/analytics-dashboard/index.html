<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Analytics Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/recharts@2.8.0/umd/Recharts.js"></script>
    <style>
        .chart-container { 
            min-height: 450px; 
            width: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: visible;
            position: relative;
            resize: both;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 20px;
            transition: border-color 0.2s ease;
            background: white; /* Ensure white background */
        }
        .chart-container:hover {
            border-color: #e5e7eb;
        }
        .chart-container:focus-within {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .chart-svg {
            width: 100%;
            height: 100%;
            max-width: 100%;
            display: block;
            visibility: visible !important;
            opacity: 1 !important;
            background-color: white;
        }
        /* Loading overlay for PDF export */
        .export-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            font-family: Arial, sans-serif;
        }
        .export-progress {
            margin-top: 20px;
            text-align: center;
        }
        .export-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .freeze-body {
            overflow: hidden !important;
            position: fixed !important;
            width: 100% !important;
        }
        .chart-tooltip {
            position: absolute !important;
            background: rgba(0, 0, 0, 0.9) !important;
            color: white !important;
            padding: 8px 12px !important;
            border-radius: 6px !important;
        }
        .dashboard-grid {
            display: grid;
            gap: 20px;
            transition: all 0.3s ease;
        }
        .grid-1-col { grid-template-columns: 1fr; }
        .grid-2-col { grid-template-columns: 1fr 1fr; }
        .grid-3-col { grid-template-columns: 1fr 1fr 1fr; }
        .grid-4-col { grid-template-columns: 1fr 1fr 1fr 1fr; }
        .widget-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            position: relative;
            overflow: hidden;
            cursor: move;
        }
        .widget-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        .widget-container[draggable="true"]:hover {
            cursor: grab;
        }
        .widget-container[draggable="true"]:active {
            cursor: grabbing;
        }
        .widget-container.drag-over {
            border: 2px dashed #3b82f6;
            background-color: #eff6ff;
        }
        .widget-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            cursor: move;
        }
        .widget-header h3 {
            margin: 0;
            font-weight: 600;
        }
        .widget-header input[type="text"] {
            background: transparent;
            border: 2px solid transparent;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.2s ease;
            width: 100%;
        }
        .widget-header input[type="text"]:hover {
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
        }
        .widget-header input[type="text"]:focus {
            outline: none;
            background: white;
            color: black;
            border-color: #3b82f6;
            cursor: text;
        }
        .widget-header select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            min-width: 80px;
        }
        .widget-header select:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .widget-header select:focus {
            outline: none;
            background: white;
            color: black;
            border-color: white;
        }
        .widget-header select option {
            color: black;
            background: white;
        }
        .widget-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .widget-action {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .widget-action:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        .heat-map-cell {
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        .heat-map-cell:hover {
            opacity: 0.8;
            stroke-width: 3px;
        }
        .bubble-chart circle {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .bubble-chart circle:hover {
            stroke: #333;
            stroke-width: 2px;
        }
        .drill-down-breadcrumb {
            background: #f3f4f6;
            padding: 8px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 14px;
        }
        .drill-down-breadcrumb button {
            background: none;
            border: none;
            color: #3b82f6;
            cursor: pointer;
            text-decoration: underline;
        }
        .config-panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e5e7eb;
        }
        .config-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }
        .config-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }
        .loading-spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .chart-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .widget-container:hover .chart-controls {
            opacity: 1;
        }
        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        .chart-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            background: linear-gradient(-45deg, transparent 30%, #cbd5e1 30%, #cbd5e1 50%, transparent 50%);
            cursor: nw-resize;
            border-radius: 0 0 8px 0;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        .chart-resize-handle:hover {
            opacity: 1;
        }
        .loading-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .gradient-bg { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .glass-effect { backdrop-filter: blur(10px); background: rgba(255, 255, 255, 0.1); }
        .hover-scale { transition: transform 0.2s ease; }
        .hover-scale:hover { transform: scale(1.02); }
        .chart-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        @media (max-width: 768px) {
            .chart-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { 
            useState, 
            useEffect, 
            useContext, 
            createContext, 
            useCallback, 
            useMemo, 
            useRef,
            createRef,
            memo,
            forwardRef,
            createElement: e 
        } = React;

        // ====================== CONSTANTS & UTILITIES ======================
        const CHART_TYPES = {
            LINE: 'line',
            BAR: 'bar',
            AREA: 'area',
            PIE: 'pie',
            DONUT: 'donut',
            SCATTER: 'scatter',
            BUBBLE: 'bubble',
            HEATMAP: 'heatmap',
            FUNNEL: 'funnel',
            TREEMAP: 'treemap'
        };

        const DATA_TYPES = {
            SALES: 'sales',
            MARKETING: 'marketing',
            FINANCE: 'finance',
            OPERATIONS: 'operations',
            CUSTOM: 'custom'
        };

        const generateUniqueId = () => `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        const formatCurrency = (value) => new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(value);

        const formatPercentage = (value) => `${Number(value).toFixed(2)}%`;

        const calculateTrend = (current, previous) => {
            if (!previous || previous === 0) return 0;
            return ((current - previous) / previous) * 100;
        };

        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // ====================== CONTEXTS ======================
        const AnalyticsContext = createContext();
        const ThemeContext = createContext();
        const NotificationContext = createContext();

        // ====================== SERVICES ======================
        class LLMService {
            static API_KEY = null; // Will be set by user
            static BASE_URL = 'https://api.openai.com/v1/chat/completions';
            
            static setApiKey(key) {
                this.API_KEY = key;
                localStorage.setItem('openai_api_key', key);
            }
            
            static getApiKey() {
                if (!this.API_KEY) {
                    this.API_KEY = localStorage.getItem('openai_api_key');
                }
                return this.API_KEY;
            }
            
            static async generateInsights(data, metrics) {
                const apiKey = this.getApiKey();
                if (!apiKey) {
                    console.warn('No OpenAI API key provided, falling back to rule-based insights');
                    return null;
                }
                
                try {
                    const prompt = this.createAnalyticsPrompt(data, metrics);
                    
                    const response = await fetch(this.BASE_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are an expert business analyst specializing in data insights and strategic recommendations. Provide actionable, specific insights based on the data provided.'
                                },
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: 1000,
                            temperature: 0.7
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    return this.parseInsightsResponse(result.choices[0].message.content);
                    
                } catch (error) {
                    console.error('LLM API call failed:', error);
                    return null;
                }
            }
            
            static createAnalyticsPrompt(data, metrics) {
                const dataDescription = this.summarizeData(data, metrics);
                
                return `Analyze this business data and provide 4-6 specific insights with recommendations:

${dataDescription}

For each insight, provide:
1. A clear identification of the trend or pattern
2. The business impact or significance
3. A specific, actionable recommendation
4. Priority level (High/Medium/Low)

Format your response as a JSON array of objects with these properties:
- metric: string (Revenue/Users/Conversion/Satisfaction/Growth/Efficiency)
- insight: string (key finding)
- recommendation: string (specific action to take)
- priority: string (High/Medium/Low)
- trend: string (Positive/Negative/Stable)

Example format:
[{"metric": "Revenue", "insight": "Revenue declined 15% in Q2", "recommendation": "Implement customer retention program", "priority": "High", "trend": "Negative"}]`;
            }
            
            static summarizeData(data, metrics) {
                if (!data || data.length === 0) return "No data available";
                
                const summary = [];
                summary.push(`Dataset: ${data.length} data points`);
                
                metrics.forEach(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const latest = values[values.length - 1];
                    const previous = values[values.length - 2] || latest;
                    const change = ((latest - previous) / previous * 100).toFixed(1);
                    
                    summary.push(`${metric}: Current=${latest.toLocaleString()}, Change=${change}%`);
                });
                
                return summary.join('\n');
            }
            
            static parseInsightsResponse(content) {
                try {
                    // Try to extract JSON from the response
                    const jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const insights = JSON.parse(jsonMatch[0]);
                        return insights.map(insight => ({
                            id: `llm-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                            metric: insight.metric || 'Analysis',
                            trend: this.convertTrendToNumber(insight.trend),
                            volatility: this.estimateVolatility(insight.priority),
                            confidence: insight.priority === 'High' ? 0.9 : insight.priority === 'Medium' ? 0.7 : 0.5,
                            recommendation: insight.recommendation || insight.insight,
                            priority: this.convertPriorityToNumber(insight.priority),
                            isLLMGenerated: true,
                            timestamp: new Date().toISOString()
                        }));
                    }
                } catch (error) {
                    console.error('Failed to parse LLM response:', error);
                }
                return null;
            }
            
            static convertTrendToNumber(trend) {
                switch(trend?.toLowerCase()) {
                    case 'positive': return 15;
                    case 'negative': return -15;
                    case 'stable': return 0;
                    default: return 0;
                }
            }
            
            static convertPriorityToNumber(priority) {
                switch(priority?.toLowerCase()) {
                    case 'high': return 0.9;
                    case 'medium': return 0.6;
                    case 'low': return 0.3;
                    default: return 0.5;
                }
            }
            
            static estimateVolatility(priority) {
                switch(priority?.toLowerCase()) {
                    case 'high': return 0.8;
                    case 'medium': return 0.4;
                    case 'low': return 0.2;
                    default: return 0.3;
                }
            }
        }

        class AnalyticsEngine {
            static async generateAdvancedInsights(data, options = {}) {
                if (!data || data.length < 2) return [];

                const metrics = ['revenue', 'users', 'conversion', 'satisfaction'];
                
                // Try LLM-powered insights first
                try {
                    const llmInsights = await LLMService.generateInsights(data, metrics);
                    if (llmInsights && llmInsights.length > 0) {
                        console.log('Generated LLM-powered insights:', llmInsights);
                        return llmInsights;
                    }
                } catch (error) {
                    console.warn('LLM insights failed, falling back to rule-based:', error);
                }

                // Fallback to rule-based insights
                console.log('Using rule-based insights as fallback');
                return this.generateRuleBasedInsights(data, metrics);
            }
            
            static generateRuleBasedInsights(data, metrics) {
                const insights = [];
                
                metrics.forEach(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const trend = this.calculateMovingAverage(values, 3);
                    const volatility = this.calculateVolatility(values);
                    const forecast = this.linearRegression(values);
                    
                    insights.push({
                        id: generateUniqueId(),
                        metric,
                        trend: trend.slice(-1)[0],
                        volatility,
                        forecast: forecast.predict(data.length),
                        confidence: this.calculateConfidence(values),
                        recommendation: this.generateRecommendation(metric, trend, volatility),
                        priority: this.calculatePriority(trend, volatility),
                        isLLMGenerated: false,
                        timestamp: new Date().toISOString()
                    });
                });

                return insights.sort((a, b) => b.priority - a.priority);
            }

            static calculateMovingAverage(data, period) {
                const result = [];
                for (let i = period - 1; i < data.length; i++) {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    result.push(sum / period);
                }
                return result;
            }

            static calculateVolatility(data) {
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;
                return Math.sqrt(variance);
            }

            static linearRegression(data) {
                const n = data.length;
                const x = data.map((_, i) => i);
                const y = data;
                
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
                const sumXX = x.reduce((acc, xi) => acc + xi * xi, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                return {
                    slope,
                    intercept,
                    predict: (x) => slope * x + intercept,
                    r2: this.calculateR2(data, slope, intercept)
                };
            }

            static calculateR2(actual, slope, intercept) {
                const predicted = actual.map((_, i) => slope * i + intercept);
                const actualMean = actual.reduce((a, b) => a + b, 0) / actual.length;
                
                const ssRes = actual.reduce((acc, val, i) => acc + Math.pow(val - predicted[i], 2), 0);
                const ssTot = actual.reduce((acc, val) => acc + Math.pow(val - actualMean, 2), 0);
                
                return 1 - (ssRes / ssTot);
            }

            static calculateConfidence(data) {
                const volatility = this.calculateVolatility(data);
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const cv = volatility / mean;
                return Math.max(0.1, Math.min(0.99, 1 - cv));
            }

            static generateRecommendation(metric, trend, volatility) {
                const recommendations = {
                    revenue: {
                        positive: "Revenue growth is strong. Consider scaling successful initiatives and exploring new markets.",
                        negative: "Revenue decline detected. Analyze customer retention and pricing strategies immediately.",
                        volatile: "Revenue shows high volatility. Implement risk management and diversification strategies."
                    },
                    users: {
                        positive: "User acquisition is performing well. Focus on retention and engagement optimization.",
                        negative: "User growth is declining. Review acquisition channels and user experience improvements.",
                        volatile: "User metrics are unstable. Investigate seasonal patterns and external factors."
                    },
                    conversion: {
                        positive: "Conversion rates are improving. Document and replicate successful tactics across channels.",
                        negative: "Conversion rates need attention. Audit user journey and optimize conversion funnels.",
                        volatile: "Conversion performance is inconsistent. A/B test different approaches for stability."
                    },
                    satisfaction: {
                        positive: "Customer satisfaction is high. Leverage positive feedback for marketing and referrals.",
                        negative: "Customer satisfaction declining. Immediate customer service and product improvements needed.",
                        volatile: "Customer satisfaction varies significantly. Investigate root causes and standardize experience."
                    }
                };

                const metricRecs = recommendations[metric] || recommendations.revenue;
                const lastTrend = trend[trend.length - 1] || 0;
                
                if (volatility > 0.3) return metricRecs.volatile;
                return lastTrend > 0 ? metricRecs.positive : metricRecs.negative;
            }

            static calculatePriority(trend, volatility) {
                const lastTrend = trend[trend.length - 1] || 0;
                let priority = 0.5;
                
                if (lastTrend < -10) priority += 0.4;
                else if (lastTrend > 15) priority += 0.3;
                
                if (volatility > 0.4) priority += 0.2;
                
                return Math.min(1, priority);
            }
        }

        class DataProcessor {
            static processCSVData(csvData) {
                try {
                    const processed = csvData.map((row, index) => ({
                        id: generateUniqueId(),
                        index,
                        ...row,
                        timestamp: row.timestamp || new Date().toISOString(),
                        revenue: Number(row.revenue) || 0,
                        users: Number(row.users) || 0,
                        conversion: Number(row.conversion) || 0,
                        satisfaction: Number(row.satisfaction) || 0
                    }));
                    
                    return this.validateData(processed);
                } catch (error) {
                    console.error('Data processing error:', error);
                    return [];
                }
            }

            static validateData(data) {
                return data.filter(item => 
                    item.revenue >= 0 && 
                    item.users >= 0 && 
                    item.conversion >= 0 && 
                    item.conversion <= 100
                );
            }

            static generateSampleData(type = DATA_TYPES.SALES, count = 12) {
                const templates = {
                    [DATA_TYPES.SALES]: this.generateSalesData(count),
                    [DATA_TYPES.MARKETING]: this.generateMarketingData(count),
                    [DATA_TYPES.FINANCE]: this.generateFinanceData(count),
                    [DATA_TYPES.OPERATIONS]: this.generateOperationsData(count)
                };
                
                return templates[type] || templates[DATA_TYPES.SALES];
            }

            static generateSalesData(count) {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return Array.from({ length: count }, (_, i) => ({
                    id: generateUniqueId(),
                    period: months[i % 12],
                    revenue: 50000 + Math.random() * 50000,
                    users: 1000 + Math.random() * 1000,
                    conversion: 2 + Math.random() * 6,
                    satisfaction: 80 + Math.random() * 20,
                    category: ['Technology', 'Healthcare', 'Finance', 'Retail', 'Education'][i % 5],
                    region: ['North', 'South', 'East', 'West'][i % 4],
                    channel: ['Online', 'Retail', 'Partner', 'Direct'][i % 4],
                    timestamp: new Date(2024, i % 12, 1).toISOString()
                }));
            }

            static generateMarketingData(count) {
                return Array.from({ length: count }, (_, i) => ({
                    id: generateUniqueId(),
                    period: `Week ${i + 1}`,
                    impressions: 100000 + Math.random() * 200000,
                    clicks: 5000 + Math.random() * 10000,
                    conversions: 200 + Math.random() * 500,
                    cost: 10000 + Math.random() * 20000,
                    ctr: 2 + Math.random() * 8,
                    cpc: 1 + Math.random() * 5,
                    roas: 2 + Math.random() * 6,
                    timestamp: new Date(2024, 0, (i + 1) * 7).toISOString()
                }));
            }

            static generateFinanceData(count) {
                return Array.from({ length: count }, (_, i) => ({
                    id: generateUniqueId(),
                    period: `Q${(i % 4) + 1} 2024`,
                    revenue: 1000000 + Math.random() * 2000000,
                    expenses: 600000 + Math.random() * 800000,
                    profit: 400000 + Math.random() * 600000,
                    cashFlow: 200000 + Math.random() * 400000,
                    assets: 5000000 + Math.random() * 5000000,
                    liabilities: 2000000 + Math.random() * 3000000,
                    timestamp: new Date(2024, i * 3, 1).toISOString()
                }));
            }

            static generateOperationsData(count) {
                return Array.from({ length: count }, (_, i) => ({
                    id: generateUniqueId(),
                    period: `Day ${i + 1}`,
                    orders: 100 + Math.random() * 500,
                    fulfilled: 80 + Math.random() * 400,
                    returned: 5 + Math.random() * 20,
                    efficiency: 80 + Math.random() * 20,
                    quality: 85 + Math.random() * 15,
                    defects: Math.random() * 5,
                    timestamp: new Date(2024, 0, i + 1).toISOString()
                }));
            }

            static generateTemplateCSV(type = DATA_TYPES.SALES) {
                const sampleData = this.generateSampleData(type, 3);
                const headers = Object.keys(sampleData[0]).filter(key => key !== 'id');
                
                let csv = headers.join(',') + '\\n';
                sampleData.forEach(row => {
                    csv += headers.map(header => row[header]).join(',') + '\\n';
                });
                
                return csv;
            }

            static generateTemplateJSON(type = DATA_TYPES.SALES) {
                const sampleData = this.generateSampleData(type, 3);
                // Remove id field from template
                const cleanData = sampleData.map(row => {
                    const { id, ...cleanRow } = row;
                    return cleanRow;
                });
                return JSON.stringify(cleanData, null, 2);
            }

            static generateTemplateXLSX(type = DATA_TYPES.SALES) {
                const sampleData = this.generateSampleData(type, 3);
                // Remove id field from template
                const cleanData = sampleData.map(row => {
                    const { id, ...cleanRow } = row;
                    return cleanRow;
                });
                
                // Create workbook and worksheet
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(cleanData);
                
                // Set column widths for better formatting
                const colWidths = Object.keys(cleanData[0]).map(() => ({ wch: 15 }));
                ws['!cols'] = colWidths;
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, `${type}_template`);
                
                return wb;
            }

            static async processUploadedFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const fileName = file.name.toLowerCase();
                            let data;
                            
                            if (fileName.endsWith('.csv')) {
                                // Process CSV
                                const csv = e.target.result;
                                const parsed = Papa.parse(csv, { header: true, skipEmptyLines: true });
                                data = parsed.data;
                            } else if (fileName.endsWith('.json')) {
                                // Process JSON
                                const jsonData = JSON.parse(e.target.result);
                                data = Array.isArray(jsonData) ? jsonData : [jsonData];
                            } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                                // Process Excel
                                const arrayBuffer = e.target.result;
                                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                                const firstSheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[firstSheetName];
                                data = XLSX.utils.sheet_to_json(worksheet);
                            } else {
                                throw new Error('Unsupported file format. Please use CSV, JSON, or XLSX files.');
                            }
                            
                            resolve(data);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('File reading failed'));
                    
                    // Read file based on type
                    if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                });
            }
        }

        class ReportGenerator {
            static overlayElement = null;
            static originalScrollPosition = 0;
            static originalBodyStyle = '';
            
            static freezeScreen(message = 'Generating PDF Report...', progress = '') {
                // Save current scroll position
                this.originalScrollPosition = window.pageYOffset;
                this.originalBodyStyle = document.body.style.cssText;
                
                // Freeze the page
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.top = `-${this.originalScrollPosition}px`;
                document.body.style.width = '100%';
                
                // Create overlay
                this.overlayElement = document.createElement('div');
                this.overlayElement.className = 'export-overlay';
                this.overlayElement.innerHTML = `
                    <div class="export-spinner"></div>
                    <h2 style="margin: 20px 0 10px 0; font-size: 24px;">${message}</h2>
                    <div class="export-progress" id="export-progress">${progress}</div>
                    <p style="margin-top: 20px; opacity: 0.8;">Please wait while we capture your charts...</p>
                `;
                document.body.appendChild(this.overlayElement);
                
                // Force a repaint to ensure overlay is visible
                this.overlayElement.offsetHeight;
            }
            
            static updateProgress(message) {
                if (this.overlayElement) {
                    const progressElement = this.overlayElement.querySelector('#export-progress');
                    if (progressElement) {
                        progressElement.textContent = message;
                    }
                }
            }
            
            static unfreezeScreen() {
                // Remove overlay
                if (this.overlayElement) {
                    document.body.removeChild(this.overlayElement);
                    this.overlayElement = null;
                }
                
                // Restore body styles
                document.body.style.cssText = this.originalBodyStyle;
                
                // Restore scroll position
                window.scrollTo(0, this.originalScrollPosition);
            }
            
            static async ensureChartReady(chartElement) {
                // Force the chart to be visible and stable before capture
                if (!chartElement) return false;
                
                // Scroll to chart and make it visible
                chartElement.scrollIntoView({ behavior: 'instant', block: 'center' });
                
                // Force style recalculation
                chartElement.style.display = 'block';
                chartElement.style.visibility = 'visible';
                chartElement.style.opacity = '1';
                
                // Force repaint by accessing offsetHeight
                chartElement.offsetHeight;
                
                // Check if chart contains an SVG or canvas
                const chartContent = chartElement.querySelector('svg') || 
                                   chartElement.querySelector('canvas') ||
                                   chartElement.querySelector('.chart-svg');
                
                if (!chartContent) {
                    console.warn('No chart content found in element');
                    return false;
                }
                
                // Wait for any animations to complete
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Final check that content has dimensions
                const hasValidDimensions = chartContent.offsetWidth > 0 && chartContent.offsetHeight > 0;
                console.log('Chart ready check:', hasValidDimensions, chartContent.offsetWidth, 'x', chartContent.offsetHeight);
                
                return hasValidDimensions;
            }
            static async convertSVGToCanvas(svgElement) {
                return new Promise((resolve, reject) => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Get SVG dimensions from viewBox or attributes, preserving aspect ratio
                        const viewBox = svgElement.getAttribute('viewBox');
                        let svgWidth, svgHeight;
                        
                        if (viewBox) {
                            const [x, y, w, h] = viewBox.split(' ').map(Number);
                            svgWidth = w;
                            svgHeight = h;
                        } else {
                            svgWidth = svgElement.getAttribute('width') || svgElement.clientWidth || 800;
                            svgHeight = svgElement.getAttribute('height') || svgElement.clientHeight || 600;
                        }
                        
                        canvas.width = parseInt(svgWidth);
                        canvas.height = parseInt(svgHeight);
                        
                        console.log('SVG to Canvas conversion:', canvas.width, 'x', canvas.height);
                        
                        // Clone the SVG and ensure it has proper dimensions
                        const svgClone = svgElement.cloneNode(true);
                        svgClone.setAttribute('width', canvas.width);
                        svgClone.setAttribute('height', canvas.height);
                        
                        const svgData = new XMLSerializer().serializeToString(svgClone);
                        
                        const img = new Image();
                        img.onload = () => {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            URL.revokeObjectURL(img.src);
                            resolve(canvas);
                        };
                        img.onerror = (error) => {
                            URL.revokeObjectURL(img.src);
                            reject(error);
                        };
                        
                        const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        img.src = url;
                    } catch (error) {
                        reject(error);
                    }
                });
            }
            static async generateComprehensiveReport(data, insights, chartRefs, options = {}) {
                console.log('PDF Generation - Data:', data?.length || 0, 'Insights:', insights?.length || 0);
                
                try {
                    // Freeze screen and show loading overlay
                    this.freezeScreen('Generating PDF Report...', 'Initializing...');
                    
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    let currentY = 15;

                    // Cover Page (compact)
                    this.updateProgress('Creating cover page...');
                    await this.addCoverPage(pdf);
                    
                    // Executive Summary (if data exists)
                    if (data && data.length > 0) {
                        this.updateProgress('Generating executive summary...');
                        pdf.addPage();
                        currentY = await this.addExecutiveSummary(pdf, data, insights);
                    }
                    
                    // Detailed Analytics (only if insights exist)
                    if (insights && insights.length > 0) {
                        this.updateProgress('Adding detailed analytics...');
                        pdf.addPage();
                        currentY = await this.addDetailedAnalytics(pdf, data, insights);
                    }
                    
                    // Charts and Visualizations with AI Insights (compact layout - 2 per page)
                    let chartsAdded = 0;
                    const totalCharts = chartRefs.filter(ref => ref?.current).length;
                    
                    for (let i = 0; i < chartRefs.length; i++) {
                        if (chartRefs[i]?.current) {
                            this.updateProgress(`Preparing chart ${chartsAdded + 1} of ${totalCharts}...`);
                            
                            const chartElement = chartRefs[i].current;
                            
                            // Ensure chart is ready for capture
                            const isReady = await this.ensureChartReady(chartElement);
                            if (!isReady) {
                                console.warn(`Skipping chart ${chartsAdded + 1} - not ready for capture`);
                                continue;
                            }
                            
                            this.updateProgress(`Capturing chart ${chartsAdded + 1} of ${totalCharts}...`);
                            
                            if (chartsAdded % 2 === 0) {
                                pdf.addPage();
                                currentY = 15;
                            }
                            
                            // Restore original display
                            const yOffset = chartsAdded % 2 === 0 ? 15 : 145; // Position for first or second chart
                            currentY = await this.addCompactChartWithInsights(pdf, chartRefs[i].current, insights, yOffset);
                            chartsAdded++;
                        }
                    }                    // Recommendations (only if insights exist)
                    if (insights && insights.length > 0) {
                        this.updateProgress('Adding recommendations...');
                        pdf.addPage();
                        await this.addRecommendations(pdf, insights);
                    }
                    
                    // Trend Predictions and Forecasting
                    if (data && data.length > 2) {
                        this.updateProgress('Generating trend analysis...');
                        pdf.addPage();
                        const trendY = await this.addTrendPredictions(pdf, data, insights);
                        
                        // Add forecasting - check if there's enough space (need at least 80mm for forecasting)
                        if (trendY && trendY < 200) {
                            // Add some spacing between sections
                            const forecastingY = await this.addForecasting(pdf, data, trendY + 20);
                        } else {
                            // Not enough space, add on new page
                            pdf.addPage();
                            await this.addForecasting(pdf, data, 20);
                        }
                    }
                    
                    this.updateProgress('Finalizing report...');
                    return pdf;
                    
                } catch (error) {
                    console.error('PDF generation failed:', error);
                    alert('Failed to generate PDF report: ' + error.message);
                    return null;
                } finally {
                    // Always unfreeze screen
                    this.unfreezeScreen();
                }
            }

            static async addCoverPage(pdf) {
                // Compact cover page design
                pdf.setFontSize(24);
                pdf.setFont("helvetica", "bold");
                pdf.setTextColor(44, 62, 80);
                pdf.text('Enterprise Analytics Report', 105, 60, { align: 'center' });
                
                pdf.setFontSize(14);
                pdf.setFont("helvetica", "normal");
                pdf.setTextColor(100, 100, 100);
                pdf.text('Comprehensive Business Intelligence Dashboard', 105, 80, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`, 105, 95, { align: 'center' });
                
                // Simple decorative line
                pdf.setDrawColor(52, 152, 219);
                pdf.setLineWidth(1);
                pdf.line(40, 110, 170, 110);
                
                // Add data summary
                pdf.setFontSize(9);
                pdf.setTextColor(60, 60, 60);
                pdf.text('Powered by Advanced Analytics Engine with AI-Enhanced Insights', 105, 120, { align: 'center' });
                
                return 130;
            }

            static async addExecutiveSummary(pdf, data, insights) {
                let y = 20;
                
                pdf.setFontSize(16);
                pdf.setFont("helvetica", "bold");
                pdf.setTextColor(52, 73, 94);
                pdf.text('Executive Summary', 15, y);
                y += 12;
                
                const latestData = data[data.length - 1];
                const metrics = [
                    { label: 'Total Revenue', value: formatCurrency(latestData.revenue || 0) },
                    { label: 'Active Users', value: (latestData.users || 0).toLocaleString() },
                    { label: 'Conversion Rate', value: formatPercentage(latestData.conversion || 0) },
                    { label: 'Satisfaction Score', value: formatPercentage(latestData.satisfaction || 0) }
                ];
                
                // Display metrics in compact format - 2 per line
                pdf.setFontSize(10);
                pdf.setFont("helvetica", "normal");
                pdf.setTextColor(0, 0, 0);
                
                for (let i = 0; i < metrics.length; i += 2) {
                    const left = `${metrics[i].label}: ${metrics[i].value}`;
                    const right = metrics[i + 1] ? `${metrics[i + 1].label}: ${metrics[i + 1].value}` : '';
                    
                    pdf.text(left, 15, y);
                    if (right) pdf.text(right, 110, y);
                    y += 6;
                }
                
                y += 8;
                pdf.setFontSize(12);
                pdf.setFont("helvetica", "bold");
                pdf.text('Key Insights:', 15, y);
                y += 8;
                
                // Only show top 2 most meaningful insights
                pdf.setFontSize(9);
                pdf.setFont("helvetica", "normal");
                const topInsights = insights
                    .filter(insight => insight?.recommendation && insight.recommendation !== 'No recommendation available.')
                    .slice(0, 2);
                
                if (topInsights.length === 0) {
                    pdf.text('Data analysis in progress - insights will be available in future reports.', 15, y);
                    y += 6;
                } else {
                    topInsights.forEach((insight, index) => {
                        const text = pdf.splitTextToSize(`${index + 1}. ${insight.recommendation}`, 175);
                        pdf.text(text, 15, y);
                        y += text.length * 4 + 3;
                    });
                }
                
                return y;
            }

            static async addDetailedAnalytics(pdf, data, insights) {
                let y = 20;
                
                pdf.setFontSize(16);
                pdf.setFont("helvetica", "bold");
                pdf.text('Detailed Analytics', 15, y);
                y += 15;
                
                if (!insights || insights.length === 0) {
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('No insights available for analysis.', 15, y);
                    return y + 15;
                }
                
                // Filter to only meaningful insights
                const meaningfulInsights = insights.filter(insight => 
                    insight && insight.recommendation && insight.recommendation !== 'No recommendation available.'
                );
                
                if (meaningfulInsights.length === 0) {
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('No meaningful insights available for detailed analysis.', 15, y);
                    return y + 15;
                }
                
                meaningfulInsights.slice(0, 5).forEach((insight, index) => { // Limit to top 5 insights
                    if (y > 240) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    pdf.setFontSize(11);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(52, 73, 94);
                    pdf.text(`${index + 1}. ${(insight.metric || 'Unknown').toUpperCase()}`, 15, y);
                    y += 8;
                    
                    pdf.setFontSize(9);
                    pdf.setFont("helvetica", "normal");
                    pdf.setTextColor(0, 0, 0);
                    
                    // Compact metrics display
                    const trend = insight.trend || 0;
                    const confidence = insight.confidence || 0;
                    const priority = insight.priority || 0;
                    
                    const metricsLine = `Trend: ${trend > 0 ? '+' : ''}${trend.toFixed(1)}% | Confidence: ${(confidence * 100).toFixed(0)}% | Priority: ${(priority * 100).toFixed(0)}%`;
                    pdf.text(metricsLine, 20, y);
                    y += 6;
                    
                    // Compact recommendation
                    const recommendation = insight.recommendation || 'No recommendation available.';
                    const recText = pdf.splitTextToSize(recommendation, 175);
                    pdf.text(recText, 20, y);
                    y += Math.max(recText.length * 4, 8) + 5;
                });
                
                return y;
            }

            static async addChartToPage(pdf, chartElement, yOffset = 15) {
                try {
                    console.log('Single chart capture starting for element:', chartElement);
                    
                    // Wait for charts to be fully rendered
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Find the actual chart element with better targeting
                    let targetElement = null;
                    const candidates = [
                        chartElement.querySelector('svg.chart-svg'),
                        chartElement.querySelector('svg'),
                        chartElement.querySelector('.recharts-wrapper svg'),
                        chartElement.querySelector('canvas'),
                        chartElement.querySelector('.chart-container svg'),
                        chartElement
                    ];
                    
                    for (const candidate of candidates) {
                        if (candidate && candidate.offsetWidth > 0 && candidate.offsetHeight > 0) {
                            targetElement = candidate;
                            break;
                        }
                    }
                    
                    if (!targetElement) {
                        console.error('No valid chart element found for single chart');
                        throw new Error('No chart element found');
                    }
                    
                    console.log('Single chart target element:', targetElement.tagName, targetElement.className);
                    
                    // Get the ACTUAL chart dimensions from the SVG's viewBox or computed dimensions
                    let actualWidth, actualHeight;
                    
                    if (targetElement.tagName === 'svg' || targetElement.tagName === 'SVG') {
                        const viewBox = targetElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, w, h] = viewBox.split(' ').map(Number);
                            actualWidth = w;
                            actualHeight = h;
                        } else {
                            actualWidth = targetElement.getAttribute('width') || targetElement.clientWidth || 800;
                            actualHeight = targetElement.getAttribute('height') || targetElement.clientHeight || 600;
                        }
                    } else {
                        actualWidth = targetElement.offsetWidth || targetElement.clientWidth || 800;
                        actualHeight = targetElement.offsetHeight || targetElement.clientHeight || 600;
                    }
                    
                    console.log('Single chart original dimensions (preserving aspect ratio):', actualWidth, 'x', actualHeight);
                    
                    // Don't force minimum dimensions - use actual chart size to preserve proportions
                    const chartAspectRatio = actualWidth / actualHeight;
                    
                    // Force visibility and prepare for capture
                    const originalStyle = targetElement.style.cssText;
                    targetElement.style.visibility = 'visible';
                    targetElement.style.opacity = '1';
                    targetElement.style.display = 'block';
                    
                    // Additional wait for any transitions
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Capture with ACTUAL dimensions to preserve chart quality and proportions
                    const canvas = await html2canvas(targetElement, {
                        scale: 1, // Use 1:1 scale to preserve actual dimensions and avoid distortion
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: '#ffffff',
                        logging: true,
                        foreignObjectRendering: false,
                        width: actualWidth,
                        height: actualHeight,
                        windowWidth: Math.max(actualWidth, window.innerWidth),
                        windowHeight: Math.max(actualHeight, window.innerHeight),
                        removeContainer: false,
                        imageTimeout: 5000
                    });
                    
                    // Restore original style
                    targetElement.style.cssText = originalStyle;
                    
                    console.log('Single chart canvas captured:', canvas.width, 'x', canvas.height);
                    
                    if (canvas.width === 0 || canvas.height === 0) {
                        // Try alternative capture method
                        console.log('Zero dimensions detected, trying alternative method...');
                        if (targetElement.tagName === 'svg' || targetElement.tagName === 'SVG') {
                            canvas = await this.convertSVGToCanvas(targetElement);
                            console.log('Alternative canvas captured:', canvas.width, 'x', canvas.height);
                        }
                        
                        if (canvas.width === 0 || canvas.height === 0) {
                            throw new Error('Canvas has zero dimensions after all attempts');
                        }
                    }
                    
                    const imgData = canvas.toDataURL('image/png', 0.9);
                    console.log('Single chart image data length:', imgData.length);
                    
                    // Calculate PDF dimensions BASED ON ACTUAL CHART ASPECT RATIO - preserve proportions
                    const maxPdfWidth = 180;
                    const maxPdfHeight = 120; // Better space for single charts
                    
                    let pdfWidth, pdfHeight;
                    if (chartAspectRatio > (maxPdfWidth / maxPdfHeight)) {
                        // Chart is wider - fit to width and maintain aspect ratio
                        pdfWidth = maxPdfWidth;
                        pdfHeight = maxPdfWidth / chartAspectRatio;
                    } else {
                        // Chart is taller - fit to height and maintain aspect ratio
                        pdfHeight = maxPdfHeight;
                        pdfWidth = maxPdfHeight * chartAspectRatio;
                    }
                    
                    // Clean title
                    const rawTitle = chartElement.querySelector('h3')?.textContent || 'Data Visualization';
                    const chartTitle = rawTitle.replace(/[📊📈🎯📋🔍⚙️🎲💡📄📤🏠💬🛒👤📦]/g, '').trim();
                    
                    pdf.setFontSize(12);
                    pdf.setFont("helvetica", "bold");
                    pdf.text(chartTitle, 15, yOffset);
                    
                    // Center the chart but preserve aspect ratio
                    const chartX = (210 - pdfWidth) / 2;
                    pdf.addImage(imgData, 'PNG', chartX, yOffset + 5, pdfWidth, pdfHeight);
                    console.log('Single chart added to PDF at:', chartX, yOffset + 5, 'with dimensions:', pdfWidth, 'x', pdfHeight, '(aspect ratio preserved)');
                    
                    return yOffset + pdfHeight + 15;
                } catch (error) {
                    console.error('Single chart capture failed:', error);
                    pdf.setFontSize(10);
                    pdf.text('Chart capture failed: ' + (error.message || 'Unknown error'), 15, yOffset + 10);
                    pdf.text('Debug: Check browser console for details', 15, yOffset + 20);
                    return yOffset + 30;
                }
            }

            static async addChartWithInsights(pdf, chartElement, insights, yOffset = 15) {
                let currentY = yOffset;
                
                try {
                    // Find the exact SVG element or chart canvas for precise capture
                    const svgElement = chartElement.querySelector('svg') || 
                                     chartElement.querySelector('.chart-svg') ||
                                     chartElement.querySelector('canvas') ||
                                     chartElement.querySelector('.recharts-wrapper svg') ||
                                     chartElement;
                    
                    // Get the ACTUAL chart dimensions from the SVG's viewBox or computed dimensions
                    let targetElement = svgElement;
                    let actualWidth, actualHeight;
                    
                    if (svgElement.tagName === 'svg') {
                        // For SVG elements, prioritize viewBox for accuracy
                        const viewBox = svgElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, w, h] = viewBox.split(' ').map(Number);
                            actualWidth = w;
                            actualHeight = h;
                        } else {
                            actualWidth = svgElement.getAttribute('width') || svgElement.clientWidth || 800;
                            actualHeight = svgElement.getAttribute('height') || svgElement.clientHeight || 600;
                        }
                    } else {
                        actualWidth = targetElement.offsetWidth || targetElement.clientWidth || 800;
                        actualHeight = targetElement.offsetHeight || targetElement.clientHeight || 600;
                    }
                    
                    console.log('Full chart capture - Target:', targetElement.tagName, 'Original dimensions (preserving aspect ratio):', actualWidth, 'x', actualHeight);
                    
                    // Calculate aspect ratio for proper scaling
                    const chartAspectRatio = actualWidth / actualHeight;
                    
                    // Allow time for any animations or rendering to complete
                    await new Promise(resolve => setTimeout(resolve, 150));
                    
                    // Capture with settings optimized for quality and aspect ratio preservation
                    const canvas = await html2canvas(targetElement, {
                        scale: 1, // Use 1:1 scale to preserve actual chart proportions
                        useCORS: true,
                        backgroundColor: '#ffffff',
                        logging: false,
                        allowTaint: false,
                        foreignObjectRendering: false,
                        width: actualWidth,
                        height: actualHeight,
                        windowWidth: window.innerWidth,
                        windowHeight: window.innerHeight,
                        x: 0,
                        y: 0,
                        scrollX: 0,
                        scrollY: 0
                    });
                    
                    const imgData = canvas.toDataURL('image/png', 0.95);
                    
                    // Calculate PDF dimensions BASED ON ACTUAL CHART ASPECT RATIO - preserve proportions
                    const maxPdfWidth = 180;
                    const maxPdfHeight = 130; // Good space for full charts with insights
                    
                    let pdfWidth, pdfHeight;
                    if (chartAspectRatio > (maxPdfWidth / maxPdfHeight)) {
                        // Chart is wider - fit to width and maintain aspect ratio
                        pdfWidth = maxPdfWidth;
                        pdfHeight = maxPdfWidth / chartAspectRatio;
                    } else {
                        // Chart is taller - fit to height and maintain aspect ratio
                        pdfHeight = maxPdfHeight;
                        pdfWidth = maxPdfHeight * chartAspectRatio;
                    }
                    
                    // Clean chart title
                    const rawTitle = chartElement.querySelector('h3')?.textContent || 
                                   chartElement.parentElement?.querySelector('h3')?.textContent || 
                                   'Data Visualization';
                    const chartTitle = rawTitle.replace(/[📊📈🎯📋🔍⚙️🎲💡📄📤🏠💬🛒👤📦]/g, '').trim();
                    
                    pdf.setFontSize(14);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(52, 73, 94);
                    pdf.text(chartTitle, 15, currentY);
                    currentY += 10;
                    
                    // Center the chart horizontally while preserving aspect ratio
                    const chartX = (210 - pdfWidth) / 2;
                    pdf.addImage(imgData, 'PNG', chartX, currentY, pdfWidth, pdfHeight);
                    console.log('Full chart added to PDF at:', chartX, currentY, 'with dimensions:', pdfWidth, 'x', pdfHeight, '(aspect ratio preserved)');
                    currentY += pdfHeight + 12;
                    
                    // Add relevant AI insights
                    const relevantInsights = this.getRelevantInsights(chartTitle, insights);
                    
                    if (relevantInsights.length > 0) {
                        pdf.setFontSize(12);
                        pdf.setFont("helvetica", "bold");
                        pdf.setTextColor(52, 73, 94);
                        pdf.text('AI Analysis & Insights', 15, currentY);
                        currentY += 8;
                        
                        pdf.setFontSize(9);
                        pdf.setFont("helvetica", "normal");
                        pdf.setTextColor(0, 0, 0);
                        
                        relevantInsights.slice(0, 2).forEach((insight, index) => {
                            if (currentY > 250) {
                                pdf.addPage();
                                currentY = 20;
                            }
                            
                            const metric = (insight.metric || 'General').toUpperCase();
                            pdf.setFont("helvetica", "bold");
                            pdf.text(`${metric}:`, 15, currentY);
                            currentY += 4;
                            
                            pdf.setFont("helvetica", "normal");
                            const trend = insight.trend || 0;
                            const confidence = insight.confidence || 0;
                            
                            const metricsText = `Trend: ${trend > 0 ? '+' : ''}${trend.toFixed(1)}% | Confidence: ${(confidence * 100).toFixed(0)}%`;
                            pdf.text(metricsText, 20, currentY);
                            currentY += 4;
                            
                            if (insight.recommendation && insight.recommendation !== 'No recommendation available.') {
                                const recText = pdf.splitTextToSize(insight.recommendation, 175);
                                pdf.text(recText.slice(0, 2), 20, currentY);
                                currentY += Math.min(recText.length, 2) * 4 + 4;
                            } else {
                                currentY += 2;
                            }
                        });
                        
                    } else if (insights.length > 0) {
                        pdf.setFontSize(10);
                        pdf.setFont("helvetica", "bold");
                        pdf.setTextColor(100, 100, 100);
                        pdf.text('Chart Summary', 15, currentY);
                        currentY += 6;
                        
                        pdf.setFontSize(9);
                        pdf.setFont("helvetica", "normal");
                        pdf.text('This visualization provides insights into your data patterns and trends.', 20, currentY);
                        currentY += 12;
                    }
                    
                    return currentY;
                    
                } catch (error) {
                    console.error('Chart with insights capture failed:', error);
                    pdf.setFontSize(12);
                    pdf.setFont("helvetica", "bold");
                    pdf.text('Chart Capture Error', 15, currentY);
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('Error: ' + (error.message || 'Unable to capture chart'), 15, currentY + 10);
                    return currentY + 25;
                }
            }

            static async addCompactChartWithInsights(pdf, chartElement, insights, yOffset = 15) {
                let currentY = yOffset;
                
                try {
                    console.log('Starting frozen chart capture for element:', chartElement);
                    
                    // Ensure chart is fully visible and rendered
                    if (chartElement) {
                        chartElement.scrollIntoView({ behavior: 'instant', block: 'center' });
                        
                        // Force repaint by accessing offsetHeight
                        chartElement.offsetHeight;
                        
                        // Additional wait for complete rendering
                        await new Promise(resolve => setTimeout(resolve, 800));
                    }
                    
                    // Find the actual chart element with better targeting
                    let targetElement = null;
                    const candidates = [
                        chartElement.querySelector('svg.chart-svg'),
                        chartElement.querySelector('svg'),
                        chartElement.querySelector('.recharts-wrapper svg'),
                        chartElement.querySelector('canvas'),
                        chartElement.querySelector('.chart-container svg'),
                        chartElement
                    ];
                    
                    for (const candidate of candidates) {
                        if (candidate && candidate.offsetWidth > 0 && candidate.offsetHeight > 0) {
                            targetElement = candidate;
                            break;
                        }
                    }
                    
                    if (!targetElement) {
                        console.error('No valid chart element found');
                        throw new Error('No chart element found');
                    }
                    
                    console.log('Target element found:', targetElement.tagName, targetElement.className);
                    
                    // Get the ACTUAL chart dimensions from the SVG's viewBox or computed dimensions
                    let actualWidth, actualHeight;
                    
                    if (targetElement.tagName === 'svg' || targetElement.tagName === 'SVG') {
                        const viewBox = targetElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, w, h] = viewBox.split(' ').map(Number);
                            actualWidth = w;
                            actualHeight = h;
                        } else {
                            actualWidth = targetElement.getAttribute('width') || targetElement.clientWidth || 800;
                            actualHeight = targetElement.getAttribute('height') || targetElement.clientHeight || 600;
                        }
                    } else {
                        actualWidth = targetElement.offsetWidth || targetElement.clientWidth || 800;
                        actualHeight = targetElement.offsetHeight || targetElement.clientHeight || 600;
                    }
                    
                    console.log('Original chart dimensions (preserving aspect ratio):', actualWidth, 'x', actualHeight);
                    
                    // Don't force minimum dimensions - use actual chart size to preserve proportions
                    const chartAspectRatio = actualWidth / actualHeight;
                    
                    // Force visibility and prepare for capture - ensure stable state
                    const originalStyle = targetElement.style.cssText;
                    targetElement.style.visibility = 'visible';
                    targetElement.style.opacity = '1';
                    targetElement.style.display = 'block';
                    targetElement.style.transform = 'none'; // Remove any transforms that might interfere
                    
                    // Force repaint and wait for stability
                    targetElement.offsetHeight;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Capture with ACTUAL dimensions to preserve chart quality and proportions
                    let canvas;
                    try {
                        canvas = await html2canvas(targetElement, {
                            scale: 1, // Use 1:1 scale to preserve actual dimensions and avoid distortion
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: '#ffffff',
                            logging: false, // Reduce console noise during frozen capture
                            foreignObjectRendering: false,
                            width: actualWidth,
                            height: actualHeight,
                            windowWidth: Math.max(actualWidth, window.innerWidth),
                            windowHeight: Math.max(actualHeight, window.innerHeight),
                            removeContainer: false,
                            imageTimeout: 8000, // Increased timeout for frozen capture
                            onclone: (clonedDoc) => {
                                // Ensure the cloned document has the same styles
                                const clonedTarget = clonedDoc.querySelector('.chart-svg') || clonedDoc.querySelector('svg');
                                if (clonedTarget) {
                                    clonedTarget.style.visibility = 'visible';
                                    clonedTarget.style.opacity = '1';
                                }
                            }
                        });
                        console.log('Chart canvas captured via html2canvas:', canvas.width, 'x', canvas.height);
                    } catch (html2canvasError) {
                        console.warn('html2canvas failed for compact chart, trying SVG fallback:', html2canvasError);
                        if (targetElement.tagName === 'svg' || targetElement.tagName === 'SVG') {
                            canvas = await this.convertSVGToCanvas(targetElement);
                            console.log('Chart canvas captured via SVG fallback:', canvas.width, 'x', canvas.height);
                        } else {
                            throw html2canvasError;
                        }
                    }
                    
                    // Restore original style
                    targetElement.style.cssText = originalStyle;
                    
                    console.log('Canvas captured:', canvas.width, 'x', canvas.height);
                    
                    if (canvas.width === 0 || canvas.height === 0) {
                        // Try alternative capture method
                        console.log('Zero dimensions detected in compact chart, trying alternative method...');
                        if (targetElement.tagName === 'svg' || targetElement.tagName === 'SVG') {
                            canvas = await this.convertSVGToCanvas(targetElement);
                            console.log('Alternative compact canvas captured:', canvas.width, 'x', canvas.height);
                        }
                        
                        if (canvas.width === 0 || canvas.height === 0) {
                            throw new Error('Canvas has zero dimensions after all attempts');
                        }
                    }
                    
                    const imgData = canvas.toDataURL('image/png', 0.9);
                    console.log('Image data length:', imgData.length);
                    
                    // Calculate PDF dimensions BASED ON ACTUAL CHART ASPECT RATIO - preserve proportions
                    const maxPdfWidth = 160;
                    const maxPdfHeight = 100; // Increased from 85 to allow better chart display
                    
                    let pdfWidth, pdfHeight;
                    if (chartAspectRatio > (maxPdfWidth / maxPdfHeight)) {
                        // Chart is wider - fit to width and maintain aspect ratio
                        pdfWidth = maxPdfWidth;
                        pdfHeight = maxPdfWidth / chartAspectRatio;
                    } else {
                        // Chart is taller - fit to height and maintain aspect ratio
                        pdfHeight = maxPdfHeight;
                        pdfWidth = maxPdfHeight * chartAspectRatio;
                    }
                    
                    // Clean chart title
                    const rawTitle = chartElement.querySelector('h3')?.textContent || 
                                   chartElement.parentElement?.querySelector('h3')?.textContent || 
                                   'Data Visualization';
                    const chartTitle = rawTitle.replace(/[📊📈🎯📋🔍⚙️🎲💡📄📤🏠💬🛒👤📦]/g, '').trim();
                    
                    pdf.setFontSize(11);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(52, 73, 94);
                    pdf.text(chartTitle, 20, currentY);
                    currentY += 7;
                    
                    // Center the chart horizontally but preserve aspect ratio
                    const chartX = (210 - pdfWidth) / 2;
                    pdf.addImage(imgData, 'PNG', chartX, currentY, pdfWidth, pdfHeight);
                    console.log('Chart added to PDF at:', chartX, currentY, 'with dimensions:', pdfWidth, 'x', pdfHeight, '(aspect ratio preserved)');
                    currentY += pdfHeight + 6;
                    
                    // Add compact AI insights
                    const relevantInsights = this.getRelevantInsights(chartTitle, insights);
                    
                    if (relevantInsights.length > 0 && (currentY + 30) < (yOffset + 125)) {
                        pdf.setFontSize(9);
                        pdf.setFont("helvetica", "bold");
                        pdf.setTextColor(52, 73, 94);
                        pdf.text('Key Insight:', 20, currentY);
                        currentY += 5;
                        
                        pdf.setFontSize(8);
                        pdf.setFont("helvetica", "normal");
                        pdf.setTextColor(0, 0, 0);
                        
                        const topInsight = relevantInsights[0];
                        if (topInsight) {
                            const trend = topInsight.trend || 0;
                            const confidence = topInsight.confidence || 0;
                            
                            const compactText = `${(topInsight.metric || 'General')}: ${trend > 0 ? '+' : ''}${trend.toFixed(1)}% (${(confidence * 100).toFixed(0)}% confidence)`;
                            pdf.text(compactText, 25, currentY);
                            currentY += 4;
                            
                            if (topInsight.recommendation && topInsight.recommendation !== 'No recommendation available.') {
                                const recText = pdf.splitTextToSize(topInsight.recommendation, 165);
                                pdf.text(recText[0], 25, currentY);
                                if (recText.length > 1 && (currentY + 4) < (yOffset + 125)) {
                                    pdf.text(recText[1], 25, currentY + 3);
                                }
                                currentY += Math.min(recText.length, 2) * 3 + 3;
                            }
                        }
                    }
                    
                    return Math.max(currentY, yOffset + 125);
                    
                } catch (error) {
                    console.error('Compact chart capture failed:', error);
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "bold");
                    pdf.text('Chart Capture Failed', 20, currentY);
                    pdf.setFontSize(8);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('Error: ' + (error.message || 'Unknown error'), 20, currentY + 5);
                    pdf.text('Debug: Check browser console for details', 20, currentY + 10);
                    return yOffset + 125;
                }
            }

            static getRelevantInsights(chartTitle, insights) {
                if (!insights || insights.length === 0) return [];
                
                // Try to match insights to chart content based on title keywords
                const titleLower = chartTitle.toLowerCase();
                const relevantInsights = insights.filter(insight => {
                    if (!insight || !insight.metric) return false;
                    
                    const metricLower = insight.metric.toLowerCase();
                    
                    // Direct matches
                    if (titleLower.includes(metricLower) || metricLower.includes(titleLower.split(' ')[0])) {
                        return true;
                    }
                    
                    // Keyword matching
                    const keywords = ['revenue', 'sales', 'users', 'conversion', 'satisfaction', 'engagement', 'growth'];
                    return keywords.some(keyword => 
                        titleLower.includes(keyword) && metricLower.includes(keyword)
                    );
                });
                
                // If no specific matches, return top priority insights
                if (relevantInsights.length === 0) {
                    return insights
                        .filter(insight => insight && insight.priority !== undefined)
                        .sort((a, b) => (b.priority || 0) - (a.priority || 0))
                        .slice(0, 2);
                }
                
                return relevantInsights;
            }

            static async addRecommendations(pdf, insights) {
                let y = 30;
                
                pdf.setFontSize(18);
                pdf.text('Strategic Recommendations', 20, y);
                y += 20;
                
                if (!insights || insights.length === 0) {
                    pdf.setFontSize(12);
                    pdf.text('No recommendations available.', 20, y);
                    return y + 20;
                }
                
                const priorityInsights = insights
                    .filter(insight => insight && insight.priority !== undefined)
                    .sort((a, b) => (b.priority || 0) - (a.priority || 0));
                
                if (priorityInsights.length === 0) {
                    pdf.setFontSize(12);
                    pdf.text('No priority insights available for recommendations.', 20, y);
                    return y + 20;
                }
                
                priorityInsights.forEach((insight, index) => {
                    if (y > 250) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    pdf.setFontSize(12);
                    const metricName = (insight.metric || 'Unknown').toUpperCase();
                    pdf.text(`${index + 1}. ${metricName} Recommendations`, 20, y);
                    y += 10;
                    
                    pdf.setFontSize(10);
                    const recommendation = insight.recommendation || 'No specific recommendation available.';
                    const text = pdf.splitTextToSize(recommendation, 170);
                    pdf.text(text, 25, y);
                    y += text.length * 5 + 10;
                    
                    // Add priority level indicator
                    const priority = insight.priority || 0;
                    const priorityLevel = priority > 0.7 ? 'High' : priority > 0.4 ? 'Medium' : 'Low';
                    pdf.setFontSize(8);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(`Priority: ${priorityLevel} (${(priority * 100).toFixed(0)}%)`, 25, y);
                    y += 8;
                    pdf.setTextColor(0, 0, 0);
                });
                
                return y;
            }

            static async addTrendPredictions(pdf, data, insights) {
                let y = 20;
                
                pdf.setFontSize(16);
                pdf.setFont("helvetica", "bold");
                pdf.setTextColor(52, 73, 94);
                pdf.text('🔮 Next Period Predictions', 15, y);
                y += 15;
                
                if (!data || data.length < 3) {
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('Insufficient data for trend predictions (minimum 3 data points required).', 15, y);
                    return y + 15;
                }
                
                // Generate predictions
                const metrics = ['revenue', 'users', 'conversion', 'satisfaction'];
                const predictions = metrics.map(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const lastThree = values.slice(-3);
                    const trend = ((lastThree[2] - lastThree[0]) / lastThree[0] * 100);
                    const prediction = lastThree[2] * (1 + trend / 100);
                    
                    return {
                        metric: metric.charAt(0).toUpperCase() + metric.slice(1),
                        current: lastThree[2],
                        predicted: prediction,
                        trend,
                        confidence: Math.max(60, Math.min(95, 85 - Math.abs(trend) * 2))
                    };
                });
                
                predictions.forEach((pred, index) => {
                    if (y > 240) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    pdf.setFontSize(11);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(44, 62, 80);
                    pdf.text(`${pred.metric}`, 15, y);
                    
                    // Trend indicator
                    const trendColor = pred.trend > 0 ? [34, 197, 94] : [239, 68, 68];
                    pdf.setTextColor(...trendColor);
                    pdf.text(`${pred.trend > 0 ? '+' : ''}${pred.trend.toFixed(1)}%`, 130, y);
                    y += 8;
                    
                    pdf.setFontSize(9);
                    pdf.setFont("helvetica", "normal");
                    pdf.setTextColor(0, 0, 0);
                    
                    const currentFormatted = pred.current.toLocaleString();
                    const predictedFormatted = pred.predicted.toLocaleString();
                    pdf.text(`Current: ${currentFormatted} → Predicted: ${predictedFormatted}`, 20, y);
                    y += 6;
                    
                    pdf.text(`Confidence: ${pred.confidence.toFixed(0)}%`, 20, y);
                    
                    // Confidence bar
                    const barWidth = 50;
                    const barHeight = 3;
                    pdf.setFillColor(229, 231, 235);
                    pdf.rect(80, y - 2, barWidth, barHeight, 'F');
                    pdf.setFillColor(59, 130, 246);
                    pdf.rect(80, y - 2, (barWidth * pred.confidence) / 100, barHeight, 'F');
                    
                    y += 12;
                });
                
                return y;
            }

            static async addForecasting(pdf, data, startY = null) {
                let y = startY || 20;
                
                // Only add title if starting fresh (not continuing from same page)
                if (startY === null || startY <= 25) {
                    pdf.setFontSize(16);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(52, 73, 94);
                    pdf.text('📊 Quarterly Forecasts', 15, y);
                    y += 15;
                } else {
                    // Add section separator when continuing on same page
                    pdf.setFontSize(14);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(52, 73, 94);
                    pdf.text('📊 Quarterly Forecasts', 15, y);
                    y += 12;
                }
                
                if (!data || data.length < 2) {
                    pdf.setFontSize(10);
                    pdf.setFont("helvetica", "normal");
                    pdf.text('Insufficient data for forecasting (minimum 2 data points required).', 15, y);
                    return y + 15;
                }
                
                // Generate linear regression forecasts
                const generateForecast = (values, periods = 3) => {
                    const n = values.length;
                    const sumX = values.reduce((acc, _, i) => acc + i, 0);
                    const sumY = values.reduce((acc, val) => acc + val, 0);
                    const sumXY = values.reduce((acc, val, i) => acc + i * val, 0);
                    const sumXX = values.reduce((acc, _, i) => acc + i * i, 0);
                    
                    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    
                    return Array.from({ length: periods }, (_, i) => ({
                        period: `Q${i + 1}`,
                        value: Math.max(0, slope * (n + i) + intercept)
                    }));
                };

                const revenueValues = data.map(d => Number(d.revenue) || 0);
                const userValues = data.map(d => Number(d.users) || 0);

                const forecasts = [
                    { metric: '💰 Revenue', forecasts: generateForecast(revenueValues) },
                    { metric: '👥 Users', forecasts: generateForecast(userValues) }
                ];
                
                forecasts.forEach((forecast, index) => {
                    // Check if we need a new page (need at least 40mm for each forecast section)
                    if (y > 240) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    pdf.setFontSize(12);
                    pdf.setFont("helvetica", "bold");
                    pdf.setTextColor(44, 62, 80);
                    pdf.text(forecast.metric, 15, y);
                    y += 10;
                    
                    // Forecast quarters in grid
                    pdf.setFontSize(9);
                    pdf.setFont("helvetica", "normal");
                    pdf.setTextColor(0, 0, 0);
                    
                    const startX = 20;
                    const colWidth = 50;
                    
                    forecast.forecasts.forEach((f, i) => {
                        const x = startX + (i * colWidth);
                        
                        // Quarter label
                        pdf.setFont("helvetica", "bold");
                        pdf.setTextColor(100, 100, 100);
                        pdf.text(f.period, x, y);
                        
                        // Value
                        pdf.setFont("helvetica", "normal");
                        pdf.setTextColor(59, 130, 246);
                        pdf.text(f.value.toLocaleString(), x, y + 6);
                    });
                    
                    y += 25; // Add more space between forecast sections
                });
                
                return y;
            }

            static async addAppendices(pdf, data) {
                pdf.setFontSize(18);
                pdf.text('Data Appendix', 20, 30);
                
                pdf.setFontSize(10);
                pdf.text('Raw data summary and methodology notes...', 20, 50);
                pdf.text(`Total data points analyzed: ${data.length}`, 20, 60);
                pdf.text(`Analysis period: ${data[0]?.timestamp?.split('T')[0]} to ${data[data.length - 1]?.timestamp?.split('T')[0]}`, 20, 70);
            }
        }

        // ====================== HIGHER ORDER COMPONENTS ======================
        const withErrorBoundary = (WrappedComponent) => {
            return class extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = { hasError: false, error: null };
                }

                static getDerivedStateFromError(error) {
                    return { hasError: true, error };
                }

                componentDidCatch(error, errorInfo) {
                    console.error('Error caught by boundary:', error, errorInfo);
                }

                render() {
                    if (this.state.hasError) {
                        return e('div', { className: 'p-8 text-center' },
                            e('h2', { className: 'text-xl font-bold text-red-600 mb-4' }, 'Something went wrong'),
                            e('p', { className: 'text-gray-600' }, 'Please refresh the page and try again.'),
                            e('button', {
                                className: 'mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600',
                                onClick: () => this.setState({ hasError: false, error: null })
                            }, 'Try Again')
                        );
                    }

                    return e(WrappedComponent, this.props);
                }
            };
        };

        const withLoading = (WrappedComponent) => {
            return memo(({ isLoading, loadingText = 'Loading...', ...props }) => {
                if (isLoading) {
                    return e('div', { className: 'flex items-center justify-center p-8' },
                        e('div', { className: 'loading-spinner w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full mr-3' }),
                        e('span', { className: 'text-gray-600' }, loadingText)
                    );
                }
                return e(WrappedComponent, props);
            });
        };

        const withAnalytics = (WrappedComponent) => {
            return memo((props) => {
                const analyticsData = useContext(AnalyticsContext);
                return e(WrappedComponent, { ...props, analytics: analyticsData });
            });
        };

        const withTheme = (WrappedComponent) => {
            return memo((props) => {
                const theme = useContext(ThemeContext);
                return e(WrappedComponent, { ...props, theme });
            });
        };

        // ====================== CUSTOM HOOKS ======================
        const useDebounce = (value, delay) => {
            const [debouncedValue, setDebouncedValue] = useState(value);

            useEffect(() => {
                const handler = setTimeout(() => setDebouncedValue(value), delay);
                return () => clearTimeout(handler);
            }, [value, delay]);

            return debouncedValue;
        };

        const useLocalStorage = (key, initialValue) => {
            const [storedValue, setStoredValue] = useState(() => {
                try {
                    const item = window.localStorage.getItem(key);
                    return item ? JSON.parse(item) : initialValue;
                } catch (error) {
                    console.error('Error reading localStorage:', error);
                    return initialValue;
                }
            });

            const setValue = useCallback((value) => {
                try {
                    setStoredValue(value);
                    window.localStorage.setItem(key, JSON.stringify(value));
                } catch (error) {
                    console.error('Error setting localStorage:', error);
                }
            }, [key]);

            return [storedValue, setValue];
        };

        const useAnalyticsData = () => {
            // Generate sample data if none exists
            const generateInitialData = () => {
                console.log('Generating initial sample data...');
                const sampleData = DataProcessor.generateSampleData(DATA_TYPES.SALES, 12);
                const enhancedData = sampleData.map((item, index) => ({
                    ...item,
                    category: ['Electronics', 'Clothing', 'Food', 'Books'][index % 4],
                    region: ['North', 'South', 'East', 'West'][index % 4]
                }));
                console.log('Initial sample data generated:', enhancedData.length, 'records');
                console.log('Sample record:', enhancedData[0]);
                return enhancedData;
            };

            const [data, setData] = useLocalStorage('analyticsData', generateInitialData());
            const [insights, setInsights] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);

            // Generate insights for initial data
            useEffect(() => {
                console.log('useEffect triggered - data length:', data.length, 'insights length:', insights.length);
                if (data.length > 0 && insights.length === 0) {
                    console.log('Generating initial insights for sample data...');
                    AnalyticsEngine.generateAdvancedInsights(data)
                        .then(generatedInsights => {
                            console.log('Initial insights generated:', generatedInsights.length);
                            setInsights(generatedInsights);
                        })
                        .catch(error => {
                            console.error('Failed to generate initial insights:', error);
                            // Set some fallback insights
                            const fallbackInsights = [
                                {
                                    id: 1,
                                    type: 'revenue',
                                    metric: 'Revenue Growth',
                                    trend: 15.2,
                                    confidence: 0.85,
                                    recommendation: 'Revenue shows strong upward trend. Consider expanding marketing in high-performing segments.'
                                },
                                {
                                    id: 2,
                                    type: 'users',
                                    metric: 'User Engagement',
                                    trend: 8.7,
                                    confidence: 0.78,
                                    recommendation: 'User growth is steady. Focus on retention strategies to maximize lifetime value.'
                                }
                            ];
                            console.log('Setting fallback insights:', fallbackInsights.length);
                            setInsights(fallbackInsights);
                        });
                }
            }, [data, insights.length]);

            const processData = useCallback(async (newData) => {
                setIsProcessing(true);
                try {
                    console.log('Processing data...', newData.length, 'records');
                    const processed = DataProcessor.processCSVData(newData);
                    console.log('Data processed, generating insights...');
                    const generatedInsights = await AnalyticsEngine.generateAdvancedInsights(processed);
                    console.log('Insights generated:', generatedInsights.length, 'insights');
                    
                    setData(processed);
                    setInsights(generatedInsights);
                } catch (error) {
                    console.error('Data processing failed:', error);
                    // Set empty insights on error to show fallback UI
                    setInsights([]);
                } finally {
                    setIsProcessing(false);
                }
            }, [setData]);

            return {
                data,
                insights,
                isProcessing,
                processData,
                setData,
                setInsights
            };
        };

        // ====================== COMPONENTS ======================
        const FileUploader = memo(({ onDataUpload, acceptedTypes = '.csv,.json,.xlsx,.xls' }) => {
            const [dragActive, setDragActive] = useState(false);
            const [uploading, setUploading] = useState(false);
            const fileInputRef = useRef(null);

            const handleDrag = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.type === "dragenter" || e.type === "dragover") {
                    setDragActive(true);
                } else if (e.type === "dragleave") {
                    setDragActive(false);
                }
            }, []);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(false);
                
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    handleFile(e.dataTransfer.files[0]);
                }
            }, []);

            const handleFile = useCallback(async (file) => {
                const fileName = file.name.toLowerCase();
                const isValidFile = fileName.endsWith('.csv') || fileName.endsWith('.json') || 
                                  fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
                
                if (!isValidFile) {
                    alert('Please upload a CSV, JSON, or Excel file');
                    return;
                }

                setUploading(true);
                
                try {
                    const data = await DataProcessor.processUploadedFile(file);
                    onDataUpload(data);
                } catch (error) {
                    console.error('File processing failed:', error);
                    alert(`Failed to process file: ${error.message}`);
                } finally {
                    setUploading(false);
                }
            }, [onDataUpload]);

            const handleInputChange = useCallback((e) => {
                if (e.target.files && e.target.files[0]) {
                    handleFile(e.target.files[0]);
                }
            }, [handleFile]);

            return e('div', {
                className: `relative border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                    dragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-gray-400'
                }`,
                onDragEnter: handleDrag,
                onDragLeave: handleDrag,
                onDragOver: handleDrag,
                onDrop: handleDrop
            },
                e('input', {
                    ref: fileInputRef,
                    type: 'file',
                    accept: acceptedTypes,
                    onChange: handleInputChange,
                    className: 'absolute inset-0 w-full h-full opacity-0 cursor-pointer'
                }),
                uploading ? 
                    e('div', { className: 'flex items-center justify-center' },
                        e('div', { className: 'loading-spinner w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full mr-2' }),
                        e('span', null, 'Processing file...')
                    ) :
                    e('div', null,
                        e('div', { className: 'text-4xl mb-4' }, '📊'),
                        e('h3', { className: 'text-lg font-semibold text-gray-700 mb-2' }, 'Upload Analytics Data'),
                        e('p', { className: 'text-gray-500 mb-4' }, 'Drag and drop your CSV, JSON, or Excel file here, or click to select'),
                        e('button', {
                            className: 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors',
                            onClick: () => fileInputRef.current?.click()
                        }, 'Choose File'),
                        e('div', { className: 'mt-2 text-xs text-gray-400' }, 'Supported formats: CSV, JSON, XLSX, XLS')
                    )
            );
        });

        const TemplateDownloader = memo(() => {
            const [selectedType, setSelectedType] = useState(DATA_TYPES.SALES);
            const [format, setFormat] = useState('csv');

            const downloadTemplate = useCallback(() => {
                try {
                    let blob, filename;
                    
                    if (format === 'csv') {
                        const csvContent = DataProcessor.generateTemplateCSV(selectedType);
                        blob = new Blob([csvContent], { type: 'text/csv' });
                        filename = `${selectedType}_template.csv`;
                    } else if (format === 'json') {
                        const jsonContent = DataProcessor.generateTemplateJSON(selectedType);
                        blob = new Blob([jsonContent], { type: 'application/json' });
                        filename = `${selectedType}_template.json`;
                    } else if (format === 'xlsx') {
                        const workbook = DataProcessor.generateTemplateXLSX(selectedType);
                        const xlsxData = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                        blob = new Blob([xlsxData], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        filename = `${selectedType}_template.xlsx`;
                    }
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    window.URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Template download error:', error);
                    alert('Error downloading template. Please try again.');
                }
            }, [selectedType, format]);

            return e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Download Data Template'),
                e('div', { className: 'mb-4' },
                    e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Select Template Type:'),
                    e('select', {
                        value: selectedType,
                        onChange: (e) => setSelectedType(e.target.value),
                        className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500'
                    },
                        Object.values(DATA_TYPES).map(type =>
                            e('option', { key: type, value: type }, 
                                type.charAt(0).toUpperCase() + type.slice(1)
                            )
                        )
                    )
                ),
                e('div', { className: 'mb-4' },
                    e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Select Format:'),
                    e('select', {
                        value: format,
                        onChange: (e) => setFormat(e.target.value),
                        className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500'
                    },
                        e('option', { value: 'csv' }, 'CSV'),
                        e('option', { value: 'json' }, 'JSON'),
                        e('option', { value: 'xlsx' }, 'Excel (XLSX)')
                    )
                ),
                e('button', {
                    onClick: downloadTemplate,
                    className: 'w-full px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors'
                }, `Download ${format.toUpperCase()} Template`)
            );
        });

        const ChartRenderer = memo(forwardRef(({ data, type, config = {}, onDataPointClick, ...props }, ref) => {
            const chartRef = useRef(null);
            const containerRef = useRef(null);

            useEffect(() => {
                if (ref) {
                    ref.current = containerRef.current;
                }
            }, [ref]);

            useEffect(() => {
                console.log('ChartRenderer: Data received:', data?.length || 0, 'Type:', type);
                if (!data || data.length === 0) {
                    console.log('ChartRenderer: No data available for chart');
                    return;
                }

                const container = d3.select(chartRef.current);
                container.selectAll("*").remove();

                // Get container dimensions for responsive sizing
                const containerRect = chartRef.current.getBoundingClientRect();
                const containerWidth = containerRect.width || 800;
                const containerHeight = containerRect.height || 400;
                
                console.log('ChartRenderer: Container dimensions:', containerWidth, 'x', containerHeight);

                const margin = { top: 20, right: 30, bottom: 40, left: 50 };
                const width = containerWidth - margin.left - margin.right;
                const height = containerHeight - margin.top - margin.bottom;

                // Create tooltip div
                const tooltip = d3.select("body").selectAll(".chart-tooltip")
                    .data([0])
                    .join("div")
                    .attr("class", "chart-tooltip")
                    .style("position", "absolute")
                    .style("background", "rgba(0, 0, 0, 0.8)")
                    .style("color", "white")
                    .style("padding", "8px 12px")
                    .style("border-radius", "4px")
                    .style("font-size", "12px")
                    .style("pointer-events", "none")
                    .style("opacity", 0)
                    .style("z-index", 10000);

                const svg = container
                    .append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                    .attr("preserveAspectRatio", "xMidYMid meet")
                    .classed("chart-svg", true)
                    .style("overflow", "visible");

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                switch (type) {
                    case CHART_TYPES.LINE:
                        renderLineChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.BAR:
                        renderBarChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.AREA:
                        renderAreaChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.SCATTER:
                        renderScatterChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.BUBBLE:
                        renderBubbleChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.HEATMAP:
                        renderHeatMap(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.PIE:
                        renderPieChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    case CHART_TYPES.DONUT:
                        renderDonutChart(g, data, width, height, config, tooltip, onDataPointClick);
                        break;
                    default:
                        renderLineChart(g, data, width, height, config, tooltip, onDataPointClick);
                }

                // Resize handler
                const handleResize = () => {
                    const newRect = chartRef.current.getBoundingClientRect();
                    const newWidth = newRect.width - margin.left - margin.right;
                    const newHeight = newRect.height - margin.top - margin.bottom;
                    
                    if (newWidth > 0 && newHeight > 0) {
                        svg.attr("viewBox", `0 0 ${newWidth + margin.left + margin.right} ${newHeight + margin.top + margin.bottom}`);
                    }
                };

                window.addEventListener('resize', handleResize);
                
                return () => {
                    window.removeEventListener('resize', handleResize);
                    tooltip.remove();
                };
            }, [data, type, config]);

            const renderLineChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'period';
                const yField = config.yField || 'revenue';

                const x = d3.scaleBand()
                    .domain(data.map(d => d[xField]))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => Number(d[yField]) || 0)])
                    .range([height, 0]);

                const line = d3.line()
                    .x(d => x(d[xField]) + x.bandwidth() / 2)
                    .y(d => y(Number(d[yField]) || 0))
                    .curve(d3.curveMonotoneX);

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                g.append("g")
                    .call(d3.axisLeft(y));

                // Add line path
                g.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", config.color || "#3b82f6")
                    .attr("stroke-width", 3)
                    .attr("d", line);

                // Add interactive dots with tooltips
                g.selectAll(".dot")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "dot")
                    .attr("cx", d => x(d[xField]) + x.bandwidth() / 2)
                    .attr("cy", d => y(Number(d[yField]) || 0))
                    .attr("r", 6)
                    .attr("fill", config.color || "#3b82f6")
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 8)
                            .attr("stroke", "white")
                            .attr("stroke-width", 2);
                        
                        const value = Number(d[yField]) || 0;
                        const formattedValue = typeof value === 'number' && value > 1000 
                            ? `$${(value/1000).toFixed(1)}K` 
                            : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d[xField]}</strong><br/>${yField}: ${formattedValue}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("click", function(event, d) {
                        if (onDataPointClick) {
                            onDataPointClick(d);
                        }
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 6)
                            .attr("stroke", "none");
                        
                        tooltip.style("opacity", 0);
                    });
            };

            const renderBarChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'period';
                const yField = config.yField || 'revenue';

                const x = d3.scaleBand()
                    .domain(data.map(d => d[xField]))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => Number(d[yField]) || 0)])
                    .range([height, 0]);

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                g.append("g")
                    .call(d3.axisLeft(y));

                // Add interactive bars with tooltips
                g.selectAll(".bar")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d[xField]))
                    .attr("width", x.bandwidth())
                    .attr("y", d => y(Number(d[yField]) || 0))
                    .attr("height", d => height - y(Number(d[yField]) || 0))
                    .attr("fill", config.color || "#10b981")
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("fill", d3.color(config.color || "#10b981").brighter(0.3))
                            .attr("stroke", "white")
                            .attr("stroke-width", 2);
                        
                        const value = Number(d[yField]) || 0;
                        const formattedValue = typeof value === 'number' && value > 1000 
                            ? `$${(value/1000).toFixed(1)}K` 
                            : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d[xField]}</strong><br/>${yField}: ${formattedValue}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("fill", config.color || "#10b981")
                            .attr("stroke", "none");
                        
                        tooltip.style("opacity", 0);
                    });
            };

            const renderAreaChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'period';
                const yField = config.yField || 'revenue';

                const x = d3.scaleBand()
                    .domain(data.map(d => d[xField]))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => Number(d[yField]) || 0)])
                    .range([height, 0]);

                const area = d3.area()
                    .x(d => x(d[xField]) + x.bandwidth() / 2)
                    .y0(height)
                    .y1(d => y(Number(d[yField]) || 0))
                    .curve(d3.curveMonotoneX);

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                g.append("g")
                    .call(d3.axisLeft(y));

                // Add area path
                g.append("path")
                    .datum(data)
                    .attr("fill", config.color || "#8b5cf6")
                    .attr("fill-opacity", 0.6)
                    .attr("d", area);

                // Add interactive dots for tooltips
                g.selectAll(".area-dot")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "area-dot")
                    .attr("cx", d => x(d[xField]) + x.bandwidth() / 2)
                    .attr("cy", d => y(Number(d[yField]) || 0))
                    .attr("r", 4)
                    .attr("fill", config.color || "#8b5cf6")
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 6);
                        
                        const value = Number(d[yField]) || 0;
                        const formattedValue = typeof value === 'number' && value > 1000 
                            ? `$${(value/1000).toFixed(1)}K` 
                            : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d[xField]}</strong><br/>${yField}: ${formattedValue}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 4);
                        
                        tooltip.style("opacity", 0);
                    });
            };

            const renderScatterChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'users';
                const yField = config.yField || 'revenue';

                const x = d3.scaleLinear()
                    .domain(d3.extent(data, d => Number(d[xField]) || 0))
                    .range([0, width]);

                const y = d3.scaleLinear()
                    .domain(d3.extent(data, d => Number(d[yField]) || 0))
                    .range([height, 0]);

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                g.append("g")
                    .call(d3.axisLeft(y));

                // Add interactive scatter dots with tooltips
                g.selectAll(".dot")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "dot")
                    .attr("cx", d => x(Number(d[xField]) || 0))
                    .attr("cy", d => y(Number(d[yField]) || 0))
                    .attr("r", 6)
                    .attr("fill", config.color || "#f59e0b")
                    .attr("fill-opacity", 0.7)
                    .attr("stroke", "white")
                    .attr("stroke-width", 1)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 8)
                            .attr("fill-opacity", 1)
                            .attr("stroke-width", 2);
                        
                        const xValue = Number(d[xField]) || 0;
                        const yValue = Number(d[yField]) || 0;
                        const formattedX = xValue.toLocaleString();
                        const formattedY = typeof yValue === 'number' && yValue > 1000 
                            ? `$${(yValue/1000).toFixed(1)}K` 
                            : yValue.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>Data Point</strong><br/>${xField}: ${formattedX}<br/>${yField}: ${formattedY}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 6)
                            .attr("fill-opacity", 0.7)
                            .attr("stroke-width", 1);
                        
                        tooltip.style("opacity", 0);
                    });
            };

            const renderBubbleChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'users';
                const yField = config.yField || 'revenue';
                const sizeField = config.sizeField || 'revenue';
                const categoryField = config.categoryField || 'category';

                const x = d3.scaleLinear()
                    .domain(d3.extent(data, d => Number(d[xField]) || 0))
                    .range([0, width]);

                const y = d3.scaleLinear()
                    .domain(d3.extent(data, d => Number(d[yField]) || 0))
                    .range([height, 0]);

                const size = d3.scaleSqrt()
                    .domain(d3.extent(data, d => Number(d[sizeField]) || 0))
                    .range([5, 40]);

                const color = d3.scaleOrdinal()
                    .domain(data.map(d => d[categoryField]))
                    .range(['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4']);

                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x));

                g.append("g")
                    .call(d3.axisLeft(y));

                // Add interactive bubbles
                g.selectAll(".bubble")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "bubble")
                    .attr("cx", d => x(Number(d[xField]) || 0))
                    .attr("cy", d => y(Number(d[yField]) || 0))
                    .attr("r", d => size(Number(d[sizeField]) || 0))
                    .attr("fill", d => color(d[categoryField]))
                    .attr("fill-opacity", 0.7)
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("fill-opacity", 1)
                            .attr("stroke-width", 3);
                        
                        const xValue = Number(d[xField]) || 0;
                        const yValue = Number(d[yField]) || 0;
                        const sizeValue = Number(d[sizeField]) || 0;
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d[categoryField] || 'Item'}</strong><br/>${xField}: ${xValue.toLocaleString()}<br/>${yField}: ${yValue.toLocaleString()}<br/>${sizeField}: ${sizeValue.toLocaleString()}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("fill-opacity", 0.7)
                            .attr("stroke-width", 2);
                        
                        tooltip.style("opacity", 0);
                    });

                // Add legend for categories
                const legend = g.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width - 100}, 20)`);

                const categories = [...new Set(data.map(d => d[categoryField]))];
                categories.forEach((category, i) => {
                    const legendRow = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    legendRow.append("circle")
                        .attr("r", 6)
                        .attr("fill", color(category));

                    legendRow.append("text")
                        .attr("x", 15)
                        .attr("y", 4)
                        .style("font-size", "12px")
                        .text(category);
                });
            };

            const renderHeatMap = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const xField = config.xField || 'period';
                const yField = config.yField || 'category';
                const valueField = config.valueField || 'revenue';

                // Get unique values for axes
                const xValues = [...new Set(data.map(d => d[xField]))];
                const yValues = [...new Set(data.map(d => d[yField]))];

                const xScale = d3.scaleBand()
                    .domain(xValues)
                    .range([0, width])
                    .padding(0.1);

                const yScale = d3.scaleBand()
                    .domain(yValues)
                    .range([0, height])
                    .padding(0.1);

                const colorScale = d3.scaleSequential()
                    .domain(d3.extent(data, d => Number(d[valueField]) || 0))
                    .interpolator(d3.interpolateViridis);

                // Create heatmap cells
                g.selectAll(".heat-cell")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "heat-cell")
                    .attr("x", d => xScale(d[xField]))
                    .attr("y", d => yScale(d[yField]))
                    .attr("width", xScale.bandwidth())
                    .attr("height", yScale.bandwidth())
                    .attr("fill", d => colorScale(Number(d[valueField]) || 0))
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.8);
                        
                        const value = Number(d[valueField]) || 0;
                        const formattedValue = value > 1000 ? `$${(value/1000).toFixed(1)}K` : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d[xField]} - ${d[yField]}</strong><br/>${valueField}: ${formattedValue}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("stroke-width", 2)
                            .attr("opacity", 1);
                        
                        tooltip.style("opacity", 0);
                    });

                // Add axes
                g.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale));

                g.append("g")
                    .call(d3.axisLeft(yScale));

                // Add color legend
                const legendWidth = 200;
                const legendHeight = 20;
                const legend = g.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width - legendWidth - 20}, ${height + 50})`);

                const legendScale = d3.scaleLinear()
                    .domain(colorScale.domain())
                    .range([0, legendWidth]);

                const legendAxis = d3.axisBottom(legendScale)
                    .ticks(5);

                legend.append("defs")
                    .append("linearGradient")
                    .attr("id", "legend-gradient")
                    .selectAll("stop")
                    .data(d3.range(0, 1.1, 0.1))
                    .enter().append("stop")
                    .attr("offset", d => `${d * 100}%`)
                    .attr("stop-color", d => colorScale(legendScale.invert(d * legendWidth)));

                legend.append("rect")
                    .attr("width", legendWidth)
                    .attr("height", legendHeight)
                    .attr("fill", "url(#legend-gradient)");

                legend.append("g")
                    .attr("transform", `translate(0, ${legendHeight})`)
                    .call(legendAxis);
            };

            const renderPieChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const valueField = config.yField || 'revenue';
                const labelField = config.xField || 'period';
                const radius = Math.min(width, height) / 2 - 60; // More space for legends

                const color = d3.scaleOrdinal()
                    .domain(data.map(d => d[labelField]))
                    .range(['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#f97316', '#84cc16']);

                const pie = d3.pie()
                    .value(d => Number(d[valueField]) || 0)
                    .sort(null);

                const arc = d3.arc()
                    .innerRadius(0)
                    .outerRadius(radius);

                const chartGroup = g.append("g")
                    .attr("transform", `translate(${width/2 - 50},${height/2})`); // Offset for legend space

                const arcs = chartGroup.selectAll(".arc")
                    .data(pie(data))
                    .enter().append("g")
                    .attr("class", "arc");

                // Add interactive pie slices with tooltips
                arcs.append("path")
                    .attr("d", arc)
                    .attr("fill", d => color(d.data[labelField]))
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("transform", function() {
                                const centroid = arc.centroid(d);
                                const translate = [centroid[0] * 0.1, centroid[1] * 0.1];
                                return `translate(${translate[0]}, ${translate[1]})`;
                            });
                        
                        const value = Number(d.data[valueField]) || 0;
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100).toFixed(1);
                        const formattedValue = typeof value === 'number' && value > 1000 
                            ? `$${(value/1000).toFixed(1)}K` 
                            : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d.data[labelField]}</strong><br/>${valueField}: ${formattedValue}<br/>Percentage: ${percentage}%`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("transform", "translate(0, 0)");
                        
                        tooltip.style("opacity", 0);
                    });

                // Clean and simple labeling - remove complex positioning
                arcs.append("text")
                    .attr("transform", d => {
                        const centroid = arc.centroid(d);
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100);
                        // Only show text for slices larger than 8% to avoid clutter
                        return percentage > 8 ? `translate(${centroid})` : null;
                    })
                    .attr("dy", "0.35em")
                    .style("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("fill", "white")
                    .style("font-weight", "bold")
                    .style("pointer-events", "none")
                    .text(d => {
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100);
                        return percentage > 8 ? `${percentage.toFixed(1)}%` : '';
                    });

                // Compact legend for pie chart - positioned better
                const legend = g.append("g")
                    .attr("transform", `translate(${width - 120}, 50)`);

                data.forEach((d, i) => {
                    const legendRow = legend.append("g")
                        .attr("transform", `translate(0, ${i * 22})`);

                    legendRow.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(d[labelField]))
                        .attr("rx", 3);

                    const value = Number(d[valueField]) || 0;
                    const formattedValue = value > 1000 ? `${(value/1000).toFixed(1)}K` : value.toLocaleString();
                    
                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .style("font-size", "12px")
                        .style("font-weight", "500")
                        .style("fill", "#374151")
                        .text(d[labelField]);
                        
                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .attr("dx", 70)
                        .style("font-size", "11px")
                        .style("fill", "#6b7280")
                        .text(formattedValue);
                });
            };

            const renderDonutChart = (g, data, width, height, config, tooltip, onDataPointClick) => {
                const valueField = config.yField || 'revenue';
                const labelField = config.xField || 'period';
                const radius = Math.min(width, height) / 2 - 60; // More space for legends
                const innerRadius = radius * 0.6;

                const color = d3.scaleOrdinal()
                    .domain(data.map(d => d[labelField]))
                    .range(['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#f97316', '#84cc16']);

                const pie = d3.pie()
                    .value(d => Number(d[valueField]) || 0)
                    .sort(null);

                const arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);

                const chartGroup = g.append("g")
                    .attr("transform", `translate(${width/2 - 50},${height/2})`); // Offset for legend space

                const arcs = chartGroup.selectAll(".arc")
                    .data(pie(data))
                    .enter().append("g")
                    .attr("class", "arc");

                // Add interactive donut slices with tooltips
                arcs.append("path")
                    .attr("d", arc)
                    .attr("fill", d => color(d.data[labelField]))
                    .attr("stroke", "white")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("transform", function() {
                                const centroid = arc.centroid(d);
                                const translate = [centroid[0] * 0.1, centroid[1] * 0.1];
                                return `translate(${translate[0]}, ${translate[1]})`;
                            });
                        
                        const value = Number(d.data[valueField]) || 0;
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100).toFixed(1);
                        const formattedValue = typeof value === 'number' && value > 1000 
                            ? `$${(value/1000).toFixed(1)}K` 
                            : value.toLocaleString();
                        
                        tooltip
                            .style("opacity", 1)
                            .html(`<strong>${d.data[labelField]}</strong><br/>${valueField}: ${formattedValue}<br/>Percentage: ${percentage}%`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mousemove", function(event) {
                        tooltip
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("transform", "translate(0, 0)");
                        
                        tooltip.style("opacity", 0);
                    });

                // Simple labeling for donut chart - only show percentages for larger slices
                arcs.append("text")
                    .attr("transform", d => {
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100);
                        if (percentage < 10) return null; // Only show for slices >= 10%
                        
                        const labelRadius = (radius + innerRadius) / 2;
                        const labelArc = d3.arc().innerRadius(labelRadius).outerRadius(labelRadius);
                        return `translate(${labelArc.centroid(d)})`;
                    })
                    .attr("dy", "0.35em")
                    .style("text-anchor", "middle")
                    .style("font-size", "10px")
                    .style("fill", "white")
                    .style("font-weight", "bold")
                    .style("pointer-events", "none")
                    .text(d => {
                        const percentage = ((d.endAngle - d.startAngle) / (2 * Math.PI) * 100);
                        return percentage >= 10 ? `${percentage.toFixed(1)}%` : '';
                    });

                // Center text
                chartGroup.append("text")
                    .attr("text-anchor", "middle")
                    .attr("dy", "-0.5em")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .style("fill", "#374151")
                    .text("Total");

                const total = data.reduce((sum, d) => sum + (Number(d[valueField]) || 0), 0);
                chartGroup.append("text")
                    .attr("text-anchor", "middle")
                    .attr("dy", "1em")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .style("fill", "#1f2937")
                    .text(total.toLocaleString());

                // Compact legend for donut chart - positioned better
                const legend = g.append("g")
                    .attr("transform", `translate(${width - 120}, 50)`);

                data.forEach((d, i) => {
                    const legendRow = legend.append("g")
                        .attr("transform", `translate(0, ${i * 22})`);

                    legendRow.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(d[labelField]))
                        .attr("rx", 3);

                    const value = Number(d[valueField]) || 0;
                    const formattedValue = value > 1000 ? `${(value/1000).toFixed(1)}K` : value.toLocaleString();
                    
                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .style("font-size", "12px")
                        .style("font-weight", "500")
                        .style("fill", "#374151")
                        .text(d[labelField]);
                        
                    legendRow.append("text")
                        .attr("x", 20)
                        .attr("y", 10)
                        .attr("dx", 70)
                        .style("font-size", "11px")
                        .style("fill", "#6b7280")
                        .text(formattedValue);
                });
            };

            return e('div', { ref: containerRef, className: 'chart-container w-full', tabIndex: 0 },
                data && data.length > 0 
                    ? e('div', { ref: chartRef, className: 'w-full h-full' })
                    : e('div', { 
                        className: 'w-full h-full flex items-center justify-center text-gray-500',
                        style: { minHeight: '300px' }
                      }, 
                      e('div', { className: 'text-center' },
                        e('div', { className: 'text-4xl mb-4' }, '📊'),
                        e('p', { className: 'text-lg' }, 'No data available'),
                        e('p', { className: 'text-sm mt-2' }, 'Upload data or wait for sample data to load')
                      )
                    ),
                e('div', { 
                    className: 'chart-resize-handle',
                    title: 'Drag to resize chart'
                })
            );
        }));

        const InsightCard = memo(({ insight, index }) => {
            const priorityColors = {
                high: 'border-red-500 bg-red-50',
                medium: 'border-yellow-500 bg-yellow-50',
                low: 'border-green-500 bg-green-50'
            };

            const getPriorityLevel = (priority) => {
                if (priority > 0.7) return 'high';
                if (priority > 0.4) return 'medium';
                return 'low';
            };

            const priorityLevel = getPriorityLevel(insight.priority);

            return e('div', {
                className: `p-6 rounded-lg border-l-4 ${priorityColors[priorityLevel]} hover-scale relative`
            },
                // LLM indicator badge
                insight.isLLMGenerated && e('div', {
                    className: 'absolute top-2 right-2 px-2 py-1 bg-purple-100 text-purple-800 text-xs rounded-full flex items-center'
                },
                    e('span', { className: 'mr-1' }, '🤖'),
                    'AI-Powered'
                ),
                e('div', { className: 'flex justify-between items-start mb-3' },
                    e('h3', { className: 'text-lg font-semibold text-gray-800' }, 
                        insight.metric.charAt(0).toUpperCase() + insight.metric.slice(1)
                    ),
                    e('span', { 
                        className: `px-2 py-1 text-xs rounded ${
                            priorityLevel === 'high' ? 'bg-red-200 text-red-800' :
                            priorityLevel === 'medium' ? 'bg-yellow-200 text-yellow-800' :
                            'bg-green-200 text-green-800'
                        }`
                    }, priorityLevel.toUpperCase())
                ),
                e('p', { className: 'text-gray-600 mb-4' }, insight.recommendation),
                e('div', { className: 'grid grid-cols-2 gap-4 text-sm' },
                    e('div', null,
                        e('span', { className: 'font-medium' }, 'Confidence: '),
                        e('span', null, `${(insight.confidence * 100).toFixed(0)}%`)
                    ),
                    e('div', null,
                        e('span', { className: 'font-medium' }, 'Trend: '),
                        e('span', { 
                            className: insight.trend > 0 ? 'text-green-600' : 'text-red-600' 
                        }, `${insight.trend > 0 ? '+' : ''}${insight.trend.toFixed(2)}%`)
                    )
                )
            );
        });

        const MetricsDashboard = memo(({ data }) => {
            const latestData = data[data.length - 1] || {};
            const previousData = data[data.length - 2] || {};

            const metrics = [
                {
                    label: 'Revenue',
                    value: latestData.revenue || 0,
                    previous: previousData.revenue || 0,
                    format: formatCurrency,
                    icon: '💰'
                },
                {
                    label: 'Users',
                    value: latestData.users || 0,
                    previous: previousData.users || 0,
                    format: (v) => v.toLocaleString(),
                    icon: '👥'
                },
                {
                    label: 'Conversion',
                    value: latestData.conversion || 0,
                    previous: previousData.conversion || 0,
                    format: formatPercentage,
                    icon: '📈'
                },
                {
                    label: 'Satisfaction',
                    value: latestData.satisfaction || 0,
                    previous: previousData.satisfaction || 0,
                    format: formatPercentage,
                    icon: '😊'
                }
            ];

            return e('div', { className: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8' },
                metrics.map(metric => {
                    const trend = calculateTrend(metric.value, metric.previous);
                    return e('div', {
                        key: metric.label,
                        className: 'bg-white p-6 rounded-lg shadow-lg hover-scale'
                    },
                        e('div', { className: 'flex items-center justify-between mb-4' },
                            e('span', { className: 'text-3xl' }, metric.icon),
                            e('span', {
                                className: `text-sm font-medium ${
                                    trend > 0 ? 'text-green-500' : trend < 0 ? 'text-red-500' : 'text-gray-500'
                                }`
                            }, `${trend > 0 ? '+' : ''}${trend.toFixed(1)}%`)
                        ),
                        e('h3', { className: 'text-gray-600 text-sm font-medium mb-2' }, metric.label),
                        e('p', { className: 'text-2xl font-bold text-gray-900' }, metric.format(metric.value))
                    );
                })
            );
        });

        const ChartControls = memo(({ activeChart, onChartChange, chartConfig, onConfigChange }) => {
            const chartTypes = [
                { type: CHART_TYPES.LINE, label: 'Line Chart', icon: '📈' },
                { type: CHART_TYPES.BAR, label: 'Bar Chart', icon: '📊' },
                { type: CHART_TYPES.AREA, label: 'Area Chart', icon: '📉' },
                { type: CHART_TYPES.PIE, label: 'Pie Chart', icon: '🥧' },
                { type: CHART_TYPES.DONUT, label: 'Donut Chart', icon: '🍩' },
                { type: CHART_TYPES.SCATTER, label: 'Scatter Plot', icon: '🎯' }
            ];

            return e('div', { className: 'bg-white rounded-lg shadow-lg p-6 mb-6' },
                e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Chart Configuration'),
                e('div', { className: 'grid grid-cols-2 md:grid-cols-3 gap-4 mb-6' },
                    chartTypes.map(chart =>
                        e('button', {
                            key: chart.type,
                            className: `p-3 rounded-lg border transition-colors ${
                                activeChart === chart.type 
                                    ? 'border-blue-500 bg-blue-50 text-blue-700' 
                                    : 'border-gray-300 hover:border-gray-400'
                            }`,
                            onClick: () => onChartChange(chart.type)
                        },
                            e('div', { className: 'text-2xl mb-2' }, chart.icon),
                            e('div', { className: 'text-sm font-medium' }, chart.label)
                        )
                    )
                ),
                e('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4' },
                    e('div', null,
                        e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'X-Axis Field'),
                        e('select', {
                            value: chartConfig.xField || 'period',
                            onChange: (e) => onConfigChange({ ...chartConfig, xField: e.target.value }),
                            className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500'
                        },
                            e('option', { value: 'period' }, 'Period'),
                            e('option', { value: 'category' }, 'Category'),
                            e('option', { value: 'region' }, 'Region')
                        )
                    ),
                    e('div', null,
                        e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Y-Axis Field'),
                        e('select', {
                            value: chartConfig.yField || 'revenue',
                            onChange: (e) => onConfigChange({ ...chartConfig, yField: e.target.value }),
                            className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500'
                        },
                            e('option', { value: 'revenue' }, 'Revenue'),
                            e('option', { value: 'users' }, 'Users'),
                            e('option', { value: 'conversion' }, 'Conversion'),
                            e('option', { value: 'satisfaction' }, 'Satisfaction')
                        )
                    ),
                    e('div', null,
                        e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Chart Color'),
                        e('input', {
                            type: 'color',
                            value: chartConfig.color || '#3b82f6',
                            onChange: (e) => onConfigChange({ ...chartConfig, color: e.target.value }),
                            className: 'w-full h-10 border border-gray-300 rounded-md'
                        })
                    )
                )
            );
        });

        // ====================== LLM CONFIGURATION COMPONENT ======================
        const LLMConfigCard = memo(() => {
            const [apiKey, setApiKey] = useState(LLMService.getApiKey() || '');
            const [isConfiguring, setIsConfiguring] = useState(false);
            const [testResult, setTestResult] = useState(null);

            const handleSaveApiKey = useCallback(() => {
                if (apiKey.trim()) {
                    LLMService.setApiKey(apiKey.trim());
                    setTestResult({ success: true, message: 'API key saved successfully!' });
                } else {
                    setTestResult({ success: false, message: 'Please enter a valid API key' });
                }
                setTimeout(() => setTestResult(null), 3000);
            }, [apiKey]);

            const handleTestConnection = useCallback(async () => {
                if (!apiKey.trim()) {
                    setTestResult({ success: false, message: 'Please enter an API key first' });
                    return;
                }

                setIsConfiguring(true);
                try {
                    const testData = [
                        { revenue: 50000, users: 1000, conversion: 3.5, satisfaction: 85 },
                        { revenue: 55000, users: 1100, conversion: 4.0, satisfaction: 87 }
                    ];
                    
                    LLMService.setApiKey(apiKey.trim());
                    const insights = await LLMService.generateInsights(testData, ['revenue', 'users']);
                    
                    if (insights && insights.length > 0) {
                        setTestResult({ success: true, message: 'LLM connection successful! AI insights are working.' });
                    } else {
                        setTestResult({ success: false, message: 'Connection successful but no insights generated.' });
                    }
                } catch (error) {
                    setTestResult({ success: false, message: `Connection failed: ${error.message}` });
                } finally {
                    setIsConfiguring(false);
                }
            }, [apiKey]);

            return e('div', { className: 'bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg shadow-lg p-6 mb-6 border border-purple-200' },
                e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                    e('span', { className: 'mr-2' }, '🤖'),
                    'LLM Configuration (OpenAI GPT)'
                ),
                e('div', { className: 'space-y-4' },
                    e('div', null,
                        e('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
                            'OpenAI API Key (for real AI insights)'
                        ),
                        e('input', {
                            type: 'password',
                            value: apiKey,
                            onChange: (e) => setApiKey(e.target.value),
                            placeholder: 'Enter your OpenAI API key...',
                            className: 'w-full p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-purple-500 focus:border-transparent'
                        })
                    ),
                    e('div', { className: 'flex gap-3' },
                        e('button', {
                            onClick: handleSaveApiKey,
                            className: 'px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors'
                        }, 'Save API Key'),
                        e('button', {
                            onClick: handleTestConnection,
                            disabled: isConfiguring,
                            className: 'px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 transition-colors'
                        }, isConfiguring ? 'Testing...' : 'Test Connection')
                    ),
                    testResult && e('div', {
                        className: `p-3 rounded-md ${testResult.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`
                    }, testResult.message),
                    e('div', { className: 'text-sm text-gray-600 bg-white p-3 rounded border' },
                        e('p', { className: 'font-medium mb-2' }, 'How to get your OpenAI API key:'),
                        e('ol', { className: 'list-decimal list-inside space-y-1' },
                            e('li', null, 'Visit '), e('a', { href: 'https://platform.openai.com/api-keys', target: '_blank', className: 'text-blue-600 hover:underline' }, 'OpenAI API Keys'),
                            e('li', null, 'Sign in or create an account'),
                            e('li', null, 'Click "Create new secret key"'),
                            e('li', null, 'Copy and paste the key above')
                        ),
                        e('p', { className: 'mt-2 text-xs text-gray-500' }, 
                            'Without an API key, the system will use rule-based insights as fallback.'
                        )
                    )
                )
            );
        });

        // ====================== TREND PREDICTIONS COMPONENTS ======================
        const TrendPredictionsCard = memo(({ data, insights }) => {
            const predictions = useMemo(() => {
                if (!data || data.length < 3) return [];
                
                const metrics = ['revenue', 'users', 'conversion', 'satisfaction'];
                return metrics.map(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const lastThree = values.slice(-3);
                    const trend = ((lastThree[2] - lastThree[0]) / lastThree[0] * 100);
                    const prediction = lastThree[2] * (1 + trend / 100);
                    
                    return {
                        metric: metric.charAt(0).toUpperCase() + metric.slice(1),
                        current: lastThree[2],
                        predicted: prediction,
                        trend,
                        confidence: Math.max(60, Math.min(95, 85 - Math.abs(trend) * 2))
                    };
                });
            }, [data]);

            return e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                    e('span', { className: 'mr-2' }, '🔮'),
                    'Next Period Predictions'
                ),
                e('div', { className: 'space-y-4' },
                    predictions.map(pred => 
                        e('div', { key: pred.metric, className: 'border-l-4 border-blue-400 pl-4 py-2' },
                            e('div', { className: 'flex justify-between items-start mb-2' },
                                e('h4', { className: 'font-medium text-gray-800' }, pred.metric),
                                e('span', { 
                                    className: `px-2 py-1 text-xs rounded-full ${
                                        pred.trend > 0 ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                                    }`
                                }, `${pred.trend > 0 ? '+' : ''}${pred.trend.toFixed(1)}%`)
                            ),
                            e('div', { className: 'text-sm text-gray-600 mb-2' },
                                `Current: ${pred.current.toLocaleString()} → Predicted: ${pred.predicted.toLocaleString()}`
                            ),
                            e('div', { className: 'flex items-center' },
                                e('div', { className: 'flex-1 bg-gray-200 rounded-full h-2 mr-2' },
                                    e('div', {
                                        className: 'bg-blue-500 h-2 rounded-full',
                                        style: { width: `${pred.confidence}%` }
                                    })
                                ),
                                e('span', { className: 'text-xs text-gray-500' }, `${pred.confidence.toFixed(0)}% confidence`)
                            )
                        )
                    )
                )
            );
        });

        const ForecastingCard = memo(({ data }) => {
            const forecasts = useMemo(() => {
                if (!data || data.length < 2) return [];
                
                const generateForecast = (values, periods = 3) => {
                    const n = values.length;
                    const sumX = values.reduce((acc, _, i) => acc + i, 0);
                    const sumY = values.reduce((acc, val) => acc + val, 0);
                    const sumXY = values.reduce((acc, val, i) => acc + i * val, 0);
                    const sumXX = values.reduce((acc, _, i) => acc + i * i, 0);
                    
                    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    
                    return Array.from({ length: periods }, (_, i) => ({
                        period: `Q${i + 1}`,
                        value: slope * (n + i) + intercept
                    }));
                };

                const revenueValues = data.map(d => Number(d.revenue) || 0);
                const userValues = data.map(d => Number(d.users) || 0);

                return [
                    { metric: 'Revenue', forecasts: generateForecast(revenueValues), icon: '💰' },
                    { metric: 'Users', forecasts: generateForecast(userValues), icon: '👥' }
                ];
            }, [data]);

            return e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                    e('span', { className: 'mr-2' }, '📊'),
                    'Quarterly Forecasts'
                ),
                e('div', { className: 'space-y-6' },
                    forecasts.map(forecast =>
                        e('div', { key: forecast.metric, className: 'border rounded-lg p-4 bg-gray-50' },
                            e('h4', { className: 'font-medium text-gray-800 mb-3 flex items-center' },
                                e('span', { className: 'mr-2' }, forecast.icon),
                                forecast.metric
                            ),
                            e('div', { className: 'grid grid-cols-3 gap-2' },
                                forecast.forecasts.map((f, i) =>
                                    e('div', { 
                                        key: i, 
                                        className: 'text-center p-2 bg-white rounded border'
                                    },
                                        e('div', { className: 'text-xs text-gray-500 mb-1' }, f.period),
                                        e('div', { className: 'font-semibold text-blue-600' }, 
                                            f.value.toLocaleString()
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        });

        // ====================== LLM CONFIGURATION COMPONENT ======================
        const LLMConfigSection = memo(() => {
            const [apiKey, setApiKey] = useState(LLMService.getApiKey() || '');
            const [testResult, setTestResult] = useState(null);
            const [isTesting, setIsTesting] = useState(false);

            const handleSaveKey = useCallback(() => {
                if (apiKey.trim()) {
                    LLMService.setApiKey(apiKey.trim());
                    setTestResult({ success: true, message: 'API key saved successfully!' });
                    setTimeout(() => setTestResult(null), 3000);
                }
            }, [apiKey]);

            const handleTestConnection = useCallback(async () => {
                if (!apiKey.trim()) {
                    setTestResult({ success: false, message: 'Please enter an API key first.' });
                    return;
                }

                setIsTesting(true);
                try {
                    LLMService.setApiKey(apiKey.trim());
                    const testData = [{ period: 'Test', revenue: 1000, users: 100 }];
                    const insights = await LLMService.generateInsights(testData, ['revenue', 'users']);
                    
                    if (insights && insights.length > 0) {
                        setTestResult({ success: true, message: 'LLM connection successful! AI insights are working.' });
                    } else {
                        setTestResult({ success: false, message: 'Connection established but no insights generated.' });
                    }
                } catch (error) {
                    setTestResult({ success: false, message: `Connection failed: ${error.message}` });
                } finally {
                    setIsTesting(false);
                }
            }, [apiKey]);

            return e('div', { className: 'space-y-4' },
                e('div', null,
                    e('label', { className: 'block text-sm font-medium text-gray-600 mb-1' }, 
                        'OpenAI API Key (for real AI insights)'
                    ),
                    e('div', { className: 'flex gap-2' },
                        e('input', {
                            type: 'password',
                            value: apiKey,
                            onChange: (e) => setApiKey(e.target.value),
                            placeholder: 'Enter your OpenAI API key...',
                            className: 'flex-1 p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500'
                        }),
                        e('button', {
                            onClick: handleSaveKey,
                            className: 'px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors'
                        }, 'Save'),
                        e('button', {
                            onClick: handleTestConnection,
                            disabled: isTesting,
                            className: 'px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors disabled:opacity-50'
                        }, isTesting ? 'Testing...' : 'Test')
                    )
                ),

                testResult && e('div', { 
                    className: `p-3 rounded-md ${testResult.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`
                }, testResult.message),

                e('div', { className: 'text-sm text-gray-600' },
                    e('p', { className: 'font-medium mb-2' }, 'How to get your OpenAI API key:'),
                    e('ol', { className: 'list-decimal list-inside space-y-1' },
                        e('li', null, 'Visit ', e('a', { href: 'https://platform.openai.com/api-keys', target: '_blank', className: 'text-blue-600 hover:underline' }, 'OpenAI API Keys')),
                        e('li', null, 'Create a new API key'),
                        e('li', null, 'Copy and paste it above'),
                        e('li', null, 'Test the connection to verify it works')
                    )
                )
            );
        });

        // ====================== TREND ANALYTICS COMPONENT ======================
        const TrendAnalyticsComponent = memo(({ data }) => {
            const trendData = useMemo(() => {
                if (!data || data.length < 2) return null;

                const metrics = ['revenue', 'users'];
                return metrics.map(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const lastThree = values.slice(-3);
                    const trend = lastThree.length >= 2 ? 
                        ((lastThree[lastThree.length - 1] - lastThree[0]) / lastThree[0] * 100) : 0;

                    return {
                        metric: metric.charAt(0).toUpperCase() + metric.slice(1),
                        trend: trend.toFixed(1),
                        direction: trend > 0 ? 'up' : trend < 0 ? 'down' : 'stable',
                        current: values[values.length - 1],
                        previous: values.length > 1 ? values[values.length - 2] : values[0]
                    };
                });
            }, [data]);

            if (!trendData) {
                return e('div', { className: 'text-center py-4 text-gray-500' },
                    e('p', null, 'Need at least 2 data points for trend analysis')
                );
            }

            return e('div', { className: 'space-y-3' },
                trendData.map((trend, index) => 
                    e('div', { key: index, className: 'flex items-center justify-between p-3 bg-gray-50 rounded-lg' },
                        e('div', null,
                            e('p', { className: 'font-medium text-gray-700' }, trend.metric),
                            e('p', { className: 'text-sm text-gray-500' }, 
                                `${trend.previous.toLocaleString()} → ${trend.current.toLocaleString()}`
                            )
                        ),
                        e('div', { className: 'flex items-center' },
                            e('span', { 
                                className: `text-lg mr-1 ${
                                    trend.direction === 'up' ? 'text-green-600' : 
                                    trend.direction === 'down' ? 'text-red-600' : 'text-gray-600'
                                }`
                            }, trend.direction === 'up' ? '↗️' : trend.direction === 'down' ? '↘️' : '➡️'),
                            e('span', { 
                                className: `font-bold ${
                                    trend.direction === 'up' ? 'text-green-600' : 
                                    trend.direction === 'down' ? 'text-red-600' : 'text-gray-600'
                                }`
                            }, `${trend.trend}%`)
                        )
                    )
                )
            );
        });

        // ====================== PREDICTIONS COMPONENT ======================
        const PredictionsComponent = memo(({ data }) => {
            const predictions = useMemo(() => {
                if (!data || data.length < 3) return null;

                const metrics = ['revenue', 'users'];
                return metrics.map(metric => {
                    const values = data.map(d => Number(d[metric]) || 0);
                    const lastThree = values.slice(-3);
                    const trend = ((lastThree[2] - lastThree[0]) / lastThree[0]) * 100;
                    const prediction = lastThree[2] * (1 + trend / 100);
                    const confidence = Math.min(95, Math.max(60, 85 - Math.abs(trend) * 0.5));

                    return {
                        metric: metric.charAt(0).toUpperCase() + metric.slice(1),
                        current: lastThree[2],
                        predicted: prediction,
                        change: ((prediction - lastThree[2]) / lastThree[2] * 100).toFixed(1),
                        confidence: confidence.toFixed(0)
                    };
                });
            }, [data]);

            if (!predictions) {
                return e('div', { className: 'text-center py-4 text-gray-500' },
                    e('p', null, 'Need at least 3 data points for predictions')
                );
            }

            return e('div', { className: 'space-y-3' },
                predictions.map((pred, index) => 
                    e('div', { key: index, className: 'p-3 bg-blue-50 rounded-lg border-l-4 border-blue-500' },
                        e('div', { className: 'flex items-center justify-between mb-2' },
                            e('p', { className: 'font-medium text-blue-800' }, pred.metric),
                            e('span', { className: 'text-sm bg-blue-200 text-blue-800 px-2 py-1 rounded' }, 
                                `${pred.confidence}% confidence`
                            )
                        ),
                        e('div', { className: 'text-sm' },
                            e('p', { className: 'text-gray-600' }, 
                                `Current: ${pred.current.toLocaleString()}`
                            ),
                            e('p', { className: 'text-blue-700 font-medium' }, 
                                `Predicted: ${pred.predicted.toLocaleString()} (${pred.change > 0 ? '+' : ''}${pred.change}%)`
                            )
                        )
                    )
                )
            );
        });

        // ====================== FORECASTS COMPONENT ======================
        const ForecastsComponent = memo(({ data }) => {
            const forecasts = useMemo(() => {
                if (!data || data.length < 4) return null;

                const revenueValues = data.map(d => Number(d.revenue) || 0);
                const quarters = ['Q1', 'Q2', 'Q3', 'Q4'];
                const currentAvg = revenueValues.reduce((a, b) => a + b, 0) / revenueValues.length;
                const growth = revenueValues.length > 1 ? 
                    ((revenueValues[revenueValues.length - 1] - revenueValues[0]) / revenueValues[0] * 100) / revenueValues.length : 5;

                return quarters.map((quarter, index) => {
                    const forecast = currentAvg * (1 + (growth * (index + 1)) / 100);
                    const variance = Math.random() * 10 - 5; // ±5% variance
                    const adjustedForecast = forecast * (1 + variance / 100);

                    return {
                        quarter,
                        forecast: adjustedForecast,
                        growth: (growth * (index + 1)).toFixed(1),
                        range: {
                            low: adjustedForecast * 0.9,
                            high: adjustedForecast * 1.1
                        }
                    };
                });
            }, [data]);

            if (!forecasts) {
                return e('div', { className: 'text-center py-4 text-gray-500' },
                    e('p', null, 'Need at least 4 data points for quarterly forecasts')
                );
            }

            return e('div', { className: 'space-y-3' },
                forecasts.map((forecast, index) => 
                    e('div', { key: index, className: 'p-3 bg-purple-50 rounded-lg border-l-4 border-purple-500' },
                        e('div', { className: 'flex items-center justify-between mb-1' },
                            e('p', { className: 'font-medium text-purple-800' }, forecast.quarter),
                            e('span', { className: 'text-sm text-purple-600' }, `+${forecast.growth}%`)
                        ),
                        e('div', { className: 'text-sm' },
                            e('p', { className: 'text-purple-700 font-medium' }, 
                                `$${(forecast.forecast / 1000).toFixed(1)}K`
                            ),
                            e('p', { className: 'text-gray-600' }, 
                                `Range: $${(forecast.range.low / 1000).toFixed(1)}K - $${(forecast.range.high / 1000).toFixed(1)}K`
                            )
                        )
                    )
                )
            );
        });

        // ====================== CONFIGURABLE DASHBOARD ======================
        const ConfigurableDashboard = () => {
            const { data, insights, isProcessing, processData, setData } = useAnalyticsData();
            console.log('ConfigurableDashboard: data length =', data.length);
            console.log('ConfigurableDashboard: sample data =', data.slice(0, 2));
            const [dashboardConfig, setDashboardConfig] = useState({
                gridColumns: 2,
                widgets: [
                    { id: 1, type: CHART_TYPES.LINE, title: 'Revenue Trend', config: { xField: 'period', yField: 'revenue' }, drillDown: [] },
                    { id: 2, type: CHART_TYPES.BAR, title: 'Performance Metrics', config: { xField: 'period', yField: 'users' }, drillDown: [] },
                    { id: 3, type: CHART_TYPES.BUBBLE, title: 'Market Analysis', config: { xField: 'users', yField: 'revenue', sizeField: 'revenue', categoryField: 'category' }, drillDown: [] },
                    { id: 4, type: CHART_TYPES.HEATMAP, title: 'Activity Heatmap', config: { xField: 'period', yField: 'category', valueField: 'revenue' }, drillDown: [] }
                ]
            });
            const [isConfigPanelOpen, setIsConfigPanelOpen] = useState(false);
            const [draggedWidget, setDraggedWidget] = useState(null);
            const [editingWidget, setEditingWidget] = useState(null);
            const [isGeneratingReport, setIsGeneratingReport] = useState(false);
            const [isExportingData, setIsExportingData] = useState(false);
            const [showExportMenu, setShowExportMenu] = useState(false);

            // Create refs for each widget chart
            const chartRefs = useRef({});
            
            // Initialize refs for all widgets
            useEffect(() => {
                dashboardConfig.widgets.forEach(widget => {
                    if (!chartRefs.current[widget.id]) {
                        chartRefs.current[widget.id] = createRef();
                    }
                });
            }, [dashboardConfig.widgets]);

            // Close export menu when clicking outside
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (showExportMenu && !event.target.closest('.export-menu-container')) {
                        setShowExportMenu(false);
                    }
                };

                if (showExportMenu) {
                    document.addEventListener('click', handleClickOutside);
                    return () => document.removeEventListener('click', handleClickOutside);
                }
            }, [showExportMenu]);

            const updateWidgetConfig = (widgetId, newConfig) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(widget => 
                        widget.id === widgetId ? { ...widget, config: { ...widget.config, ...newConfig } } : widget
                    )
                }));
            };

            const updateWidgetTitle = (widgetId, newTitle) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(widget => 
                        widget.id === widgetId ? { ...widget, title: newTitle } : widget
                    )
                }));
            };

            const updateWidgetType = (widgetId, newType) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(widget => 
                        widget.id === widgetId ? { ...widget, type: newType } : widget
                    )
                }));
            };

            const addWidget = () => {
                const newWidget = {
                    id: Date.now(),
                    type: CHART_TYPES.LINE,
                    title: `New Widget ${dashboardConfig.widgets.length + 1}`,
                    config: { xField: 'period', yField: 'revenue' },
                    drillDown: []
                };
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: [...prev.widgets, newWidget]
                }));
            };

            const removeWidget = (widgetId) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.filter(widget => widget.id !== widgetId)
                }));
            };

            const reorderWidgets = (fromIndex, toIndex) => {
                setDashboardConfig(prev => {
                    const newWidgets = [...prev.widgets];
                    const [moved] = newWidgets.splice(fromIndex, 1);
                    newWidgets.splice(toIndex, 0, moved);
                    return { ...prev, widgets: newWidgets };
                });
            };

            const getAvailableFields = () => {
                if (data.length === 0) return [];
                return Object.keys(data[0]).filter(key => key !== 'id');
            };

            const downloadChart = (widgetId, title) => {
                const chartRef = chartRefs.current[widgetId];
                if (chartRef && chartRef.current) {
                    const svg = chartRef.current.querySelector('svg');
                    if (svg) {
                        const svgData = new XMLSerializer().serializeToString(svg);
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            const pngFile = canvas.toDataURL('image/png');
                            
                            const downloadLink = document.createElement('a');
                            downloadLink.download = `${title.replace(/\s+/g, '_')}_chart.png`;
                            downloadLink.href = pngFile;
                            downloadLink.click();
                        };
                        
                        img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
                    }
                }
            };

            const drillDown = (widgetId, dataPoint) => {
                const widget = dashboardConfig.widgets.find(w => w.id === widgetId);
                if (!widget) return;

                const newLevel = {
                    field: widget.config.xField,
                    value: dataPoint[widget.config.xField],
                    timestamp: Date.now()
                };

                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(w => 
                        w.id === widgetId 
                            ? { ...w, drillDown: [...w.drillDown, newLevel] }
                            : w
                    )
                }));
            };

            const drillUp = (widgetId, level = 1) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(w => 
                        w.id === widgetId 
                            ? { ...w, drillDown: w.drillDown.slice(0, -level) }
                            : w
                    )
                }));
            };

            const resetDrillDown = (widgetId) => {
                setDashboardConfig(prev => ({
                    ...prev,
                    widgets: prev.widgets.map(w => 
                        w.id === widgetId 
                            ? { ...w, drillDown: [] }
                            : w
                    )
                }));
            };

            const getFilteredData = (widget) => {
                console.log('getFilteredData called for widget:', widget.id, 'data length:', data.length);
                let filteredData = [...data];
                console.log('Initial filteredData length:', filteredData.length);
                
                widget.drillDown.forEach(drill => {
                    filteredData = filteredData.filter(item => item[drill.field] === drill.value);
                    console.log(`After drill ${drill.field}=${drill.value}, filteredData length:`, filteredData.length);
                });

                console.log('Final filteredData length for widget', widget.id, ':', filteredData.length);
                return filteredData;
            };

            const handleDataUpload = useCallback((uploadedData) => {
                processData(uploadedData);
            }, [processData]);

            const generateComprehensiveReport = useCallback(async () => {
                setIsGeneratingReport(true);
                try {
                    // Convert chartRefs object to array format expected by ReportGenerator
                    const chartRefsArray = dashboardConfig.widgets.map(widget => 
                        chartRefs.current[widget.id]
                    ).filter(ref => ref && ref.current);
                    
                    console.log('Generating report with', chartRefsArray.length, 'charts and', insights.length, 'insights');
                    
                    const pdf = await ReportGenerator.generateComprehensiveReport(
                        data, 
                        insights, 
                        chartRefsArray
                    );
                    pdf.save(`configurable-dashboard-report-${new Date().toISOString().split('T')[0]}.pdf`);
                } catch (error) {
                    console.error('Report generation failed:', error);
                    alert('Failed to generate report. Please try again.');
                } finally {
                    setIsGeneratingReport(false);
                }
            }, [data, insights, dashboardConfig.widgets]);

            const exportData = useCallback(async (format) => {
                setIsExportingData(true);
                try {
                    let content, filename, mimeType;
                    
                    switch (format) {
                        case 'csv':
                            content = DataProcessor.generateCSV(data);
                            filename = `dashboard-data-${new Date().toISOString().split('T')[0]}.csv`;
                            mimeType = 'text/csv';
                            break;
                        case 'json':
                            content = JSON.stringify(data, null, 2);
                            filename = `dashboard-data-${new Date().toISOString().split('T')[0]}.json`;
                            mimeType = 'application/json';
                            break;
                        case 'xlsx':
                            const workbook = XLSX.utils.book_new();
                            const worksheet = XLSX.utils.json_to_sheet(data);
                            XLSX.utils.book_append_sheet(workbook, worksheet, 'Dashboard Data');
                            
                            // Add analytics summary sheet
                            const summary = [
                                { Metric: 'Total Records', Value: data.length },
                                { Metric: 'Date Range', Value: `${data[0]?.period} to ${data[data.length - 1]?.period}` },
                                { Metric: 'Total Revenue', Value: data.reduce((sum, item) => sum + (Number(item.revenue) || 0), 0) },
                                { Metric: 'Total Users', Value: data.reduce((sum, item) => sum + (Number(item.users) || 0), 0) },
                                { Metric: 'Export Date', Value: new Date().toLocaleDateString() }
                            ];
                            const summarySheet = XLSX.utils.json_to_sheet(summary);
                            XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
                            
                            const xlsxData = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                            const blob = new Blob([xlsxData], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `dashboard-data-${new Date().toISOString().split('T')[0]}.xlsx`;
                            a.click();
                            URL.revokeObjectURL(url);
                            return;
                    }
                    
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Data export failed:', error);
                    alert('Failed to export data. Please try again.');
                } finally {
                    setIsExportingData(false);
                }
            }, [data]);

            // Widget Configuration Modal
            const WidgetConfigModal = () => {
                console.log('WidgetConfigModal render - editingWidget:', editingWidget);
                if (!editingWidget) return null;
                
                const availableFields = getAvailableFields();
                console.log('Available fields:', availableFields);
                
                return e('div', { 
                    className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
                    onClick: (e) => {
                        console.log('Modal background clicked');
                        setEditingWidget(null);
                    }
                },
                    e('div', { 
                        className: 'bg-white rounded-lg p-6 w-96 max-w-lg mx-4 max-h-[80vh] overflow-y-auto shadow-2xl',
                        onClick: (e) => e.stopPropagation()
                    },
                        e('div', { className: 'flex justify-between items-center mb-6' },
                            e('h3', { className: 'text-xl font-bold text-gray-800' }, 'Configure Widget'),
                            e('button', {
                                onClick: () => setEditingWidget(null),
                                className: 'text-gray-400 hover:text-gray-600 text-2xl font-bold'
                            }, '×')
                        ),
                        
                        // Widget Title
                        e('div', { className: 'mb-6' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, 'Widget Title'),
                            e('input', {
                                type: 'text',
                                value: editingWidget.title,
                                onChange: (e) => {
                                    console.log('Title changed to:', e.target.value);
                                    setEditingWidget(prev => ({ ...prev, title: e.target.value }));
                                },
                                placeholder: 'Enter widget title...',
                                className: 'w-full border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg'
                            })
                        ),
                        
                        // Chart Type
                        e('div', { className: 'mb-6' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, 'Chart Type'),
                            e('select', {
                                value: editingWidget.type,
                                onChange: (e) => {
                                    console.log('Chart type changed to:', e.target.value);
                                    setEditingWidget(prev => ({ ...prev, type: e.target.value }));
                                },
                                className: 'w-full border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg bg-white'
                            },
                                Object.entries(CHART_TYPES).map(([key, value]) => 
                                    e('option', { key: value, value }, key.charAt(0) + key.slice(1).toLowerCase())
                                )
                            )
                        ),
                        
                        // X-Axis Field
                        e('div', { className: 'mb-6' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, 'X-Axis Field (Categories)'),
                            e('select', {
                                value: editingWidget.config.xField || '',
                                onChange: (e) => {
                                    console.log('X-field changed to:', e.target.value);
                                    setEditingWidget(prev => ({ 
                                        ...prev, 
                                        config: { ...prev.config, xField: e.target.value }
                                    }));
                                },
                                className: 'w-full border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg bg-white appearance-none'
                            },
                                e('option', { value: '' }, '📊 Select X-axis field...'),
                                availableFields.map(field => 
                                    e('option', { key: field, value: field }, `📈 ${field}`)
                                )
                            ),
                            e('p', { className: 'text-xs text-gray-500 mt-1' }, 'Choose the field for horizontal axis (categories)')
                        ),
                        
                        // Y-Axis Field
                        e('div', { className: 'mb-6' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, 'Y-Axis Field (Values)'),
                            e('select', {
                                value: editingWidget.config.yField || '',
                                onChange: (e) => {
                                    console.log('Y-field changed to:', e.target.value);
                                    setEditingWidget(prev => ({ 
                                        ...prev, 
                                        config: { ...prev.config, yField: e.target.value }
                                    }));
                                },
                                className: 'w-full border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg bg-white appearance-none'
                            },
                                e('option', { value: '' }, '📊 Select Y-axis field...'),
                                availableFields.map(field => 
                                    e('option', { key: field, value: field }, `📈 ${field}`)
                                )
                            ),
                            e('p', { className: 'text-xs text-gray-500 mt-1' }, 'Choose the field for vertical axis (numeric values)')
                        ),
                        
                        // Additional fields for specific chart types
                        (editingWidget.type === CHART_TYPES.BUBBLE || editingWidget.type === CHART_TYPES.HEATMAP) && 
                        e('div', { className: 'mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, 
                                editingWidget.type === CHART_TYPES.BUBBLE ? '🫧 Size Field (Bubble Size)' : '🔥 Value Field (Heat Intensity)'
                            ),
                            e('select', {
                                value: editingWidget.config.sizeField || editingWidget.config.valueField || '',
                                onChange: (e) => {
                                    const fieldName = editingWidget.type === CHART_TYPES.BUBBLE ? 'sizeField' : 'valueField';
                                    console.log(`${fieldName} changed to:`, e.target.value);
                                    setEditingWidget(prev => ({ 
                                        ...prev, 
                                        config: { ...prev.config, [fieldName]: e.target.value }
                                    }));
                                },
                                className: 'w-full border-2 border-blue-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-lg bg-white'
                            },
                                e('option', { value: '' }, editingWidget.type === CHART_TYPES.BUBBLE ? '🫧 Select size field...' : '🔥 Select value field...'),
                                availableFields.map(field => 
                                    e('option', { key: field, value: field }, `📊 ${field}`)
                                )
                            ),
                            e('p', { className: 'text-xs text-blue-600 mt-1' }, 
                                editingWidget.type === CHART_TYPES.BUBBLE ? 
                                'Controls the size of bubbles in the chart' : 
                                'Controls the color intensity in the heatmap'
                            )
                        ),
                        
                        // Category Field for Bubble charts
                        editingWidget.type === CHART_TYPES.BUBBLE && 
                        e('div', { className: 'mb-6 p-4 bg-green-50 border border-green-200 rounded-lg' },
                            e('label', { className: 'block text-sm font-bold text-gray-700 mb-2' }, '🏷️ Category Field (Grouping)'),
                            e('select', {
                                value: editingWidget.config.categoryField || '',
                                onChange: (e) => {
                                    console.log('Category field changed to:', e.target.value);
                                    setEditingWidget(prev => ({ 
                                        ...prev, 
                                        config: { ...prev.config, categoryField: e.target.value }
                                    }));
                                },
                                className: 'w-full border-2 border-green-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-green-500 text-lg bg-white'
                            },
                                e('option', { value: '' }, '🏷️ Select category field...'),
                                availableFields.map(field => 
                                    e('option', { key: field, value: field }, `📂 ${field}`)
                                )
                            ),
                            e('p', { className: 'text-xs text-green-600 mt-1' }, 'Groups bubbles by different categories/colors')
                        ),
                        
                        // Action buttons
                        e('div', { className: 'flex justify-end space-x-4 mt-8 pt-6 border-t border-gray-200' },
                            e('button', {
                                onClick: () => setEditingWidget(null),
                                className: 'px-6 py-3 border-2 border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 font-semibold transition-all duration-200'
                            }, '❌ Cancel'),
                            e('button', {
                                onClick: () => {
                                    console.log('Saving widget configuration:', editingWidget);
                                    updateWidgetTitle(editingWidget.id, editingWidget.title);
                                    updateWidgetType(editingWidget.id, editingWidget.type);
                                    updateWidgetConfig(editingWidget.id, editingWidget.config);
                                    setEditingWidget(null);
                                },
                                className: 'px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-semibold transition-all duration-200 shadow-lg'
                            }, '✅ Save Changes')
                        )
                    )
                );
            };

            return e('div', { className: 'min-h-screen bg-gray-50' },
                // Header
                e('div', { className: 'bg-white shadow-sm border-b border-gray-200 mb-6' },
                    e('div', { className: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4' },
                        e('div', { className: 'flex justify-between items-center' },
                            e('div', null,
                                e('h1', { className: 'text-3xl font-bold text-gray-900' }, '📊 Configurable Analytics Dashboard'),
                                e('p', { className: 'text-gray-600 mt-1' }, 'Customize your view and drill down into your data')
                            ),
                            e('div', { className: 'flex gap-3' },
                                e('button', {
                                    onClick: () => setIsConfigPanelOpen(!isConfigPanelOpen),
                                    className: `px-4 py-2 rounded-lg transition-colors ${isConfigPanelOpen ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`
                                }, isConfigPanelOpen ? 'Hide Config' : 'Configure Dashboard'),
                                
                                // Export Dropdown
                                e('div', { className: 'relative inline-block export-menu-container' },
                                    e('button', {
                                        onClick: () => setShowExportMenu(!showExportMenu),
                                        className: 'px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors flex items-center gap-2',
                                        disabled: isGeneratingReport || isExportingData
                                    }, 
                                        '📤 Export',
                                        e('svg', { className: 'w-4 h-4', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' },
                                            e('path', { strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: 2, d: 'M19 9l-7 7-7-7' })
                                        )
                                    ),
                                    showExportMenu && e('div', {
                                        className: 'absolute right-0 mt-2 w-56 bg-white rounded-md shadow-lg border border-gray-200 z-50'
                                    },
                                        e('div', { className: 'py-1' },
                                            e('div', { className: 'px-4 py-2 text-sm font-medium text-gray-700 bg-gray-50 border-b' }, 'PDF Reports'),
                                            e('button', {
                                                onClick: () => {
                                                    setShowExportMenu(false);
                                                    generateComprehensiveReport();
                                                },
                                                className: 'w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2',
                                                disabled: isGeneratingReport
                                            }, 
                                                '📄 Complete Dashboard Report',
                                                isGeneratingReport && e('span', { className: 'text-xs text-blue-600' }, '(Generating...)')
                                            ),
                                            e('div', { className: 'px-4 py-2 text-sm font-medium text-gray-700 bg-gray-50 border-b border-t' }, 'Data Export'),
                                            e('button', {
                                                onClick: () => {
                                                    setShowExportMenu(false);
                                                    exportData('csv');
                                                },
                                                className: 'w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center gap-2',
                                                disabled: isExportingData
                                            }, 
                                                '📊 Export as CSV',
                                                isExportingData && e('span', { className: 'text-xs text-blue-600' }, '(Exporting...)')
                                            ),
                                            e('button', {
                                                onClick: () => {
                                                    setShowExportMenu(false);
                                                    exportData('json');
                                                },
                                                className: 'w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100',
                                                disabled: isExportingData
                                            }, '🔧 Export as JSON'),
                                            e('button', {
                                                onClick: () => {
                                                    setShowExportMenu(false);
                                                    exportData('xlsx');
                                                },
                                                className: 'w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100',
                                                disabled: isExportingData
                                            }, '📈 Export as Excel')
                                        )
                                    )
                                ),
                                
                                e('button', {
                                    onClick: addWidget,
                                    className: 'px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors'
                                }, '+ Add Widget'),
                                e('button', {
                                    onClick: () => {
                                        const newData = DataProcessor.generateSampleData(DATA_TYPES.SALES, 12);
                                        const enhancedData = newData.map((item, index) => ({
                                            ...item,
                                            category: ['Mobile', 'Desktop', 'Tablet'][index % 3],
                                            region: ['North', 'South', 'East', 'West'][index % 4]
                                        }));
                                        processData(enhancedData);
                                    },
                                    className: 'px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors'
                                }, '🎲 New Data')
                            )
                        )
                    )
                ),

                // Configuration Panel
                isConfigPanelOpen && e('div', { className: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6' },
                    e('div', { className: 'config-panel' },
                        e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, '⚙️ Dashboard Configuration'),
                        
                        e('div', { className: 'config-section' },
                            e('h4', { className: 'font-medium text-gray-700 mb-2' }, 'Grid Layout'),
                            e('div', { className: 'config-grid' },
                                e('div', null,
                                    e('label', { className: 'block text-sm font-medium text-gray-600 mb-1' }, 'Columns'),
                                    e('select', {
                                        value: dashboardConfig.gridColumns,
                                        onChange: (e) => setDashboardConfig(prev => ({ ...prev, gridColumns: parseInt(e.target.value) })),
                                        className: 'w-full p-2 border border-gray-300 rounded-md'
                                    },
                                        e('option', { value: 1 }, '1 Column'),
                                        e('option', { value: 2 }, '2 Columns'),
                                        e('option', { value: 3 }, '3 Columns'),
                                        e('option', { value: 4 }, '4 Columns')
                                    )
                                )
                            )
                        ),

                        e('div', { className: 'config-section' },
                            e('h4', { className: 'font-medium text-gray-700 mb-2' }, 'Data Upload'),
                            e(FileUploader, { onDataUpload: handleDataUpload })
                        ),

                        e('div', { className: 'config-section' },
                            e('h4', { className: 'font-medium text-gray-700 mb-2' }, 'Template Downloads'),
                            e(TemplateDownloader)
                        ),

                        e('div', { className: 'config-section' },
                            e('h4', { className: 'font-medium text-gray-700 mb-2' }, 'LLM Configuration (OpenAI GPT)'),
                            e(LLMConfigSection)
                        )
                    )
                ),

                // Analytics & Predictions Panel
                data.length > 0 && e('div', { className: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mb-6' },
                    e('div', { className: 'grid grid-cols-1 lg:grid-cols-3 gap-6' },
                        // Trend Analytics
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                                e('span', { className: 'text-2xl mr-2' }, '📈'),
                                'Trend Analytics'
                            ),
                            e(TrendAnalyticsComponent, { data })
                        ),

                        // Next Period Predictions
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                                e('span', { className: 'text-2xl mr-2' }, '🔮'),
                                'Next Period Predictions'
                            ),
                            e(PredictionsComponent, { data })
                        ),

                        // Quarterly Forecasts
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4 flex items-center' },
                                e('span', { className: 'text-2xl mr-2' }, '📊'),
                                'Quarterly Forecasts'
                            ),
                            e(ForecastsComponent, { data })
                        )
                    )
                ),

                // Dashboard Grid
                e('div', { className: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8' },
                    // Debug info display
                    e('div', { className: 'mb-4 p-4 bg-yellow-100 border border-yellow-300 rounded-lg' },
                        e('h3', { className: 'font-bold text-yellow-800' }, 'Debug Info:'),
                        e('p', { className: 'text-yellow-700' }, `Data Count: ${data.length} records`),
                        data.length > 0 && e('p', { className: 'text-yellow-700 text-sm' }, 
                            `Sample fields: ${Object.keys(data[0]).join(', ')}`
                        )
                    ),

                    // Global KPI Configuration Panel
                    e('div', { className: 'mb-6 p-6 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg shadow-md' },
                        e('h3', { className: 'text-xl font-bold text-gray-800 mb-4 flex items-center' },
                            e('span', { className: 'mr-2' }, '📊'),
                            'Available Data Fields (KPIs)'
                        ),
                        e('div', { className: 'grid grid-cols-2 md:grid-cols-4 gap-4' },
                            getAvailableFields().map(field => 
                                e('div', { 
                                    key: field,
                                    className: 'p-3 bg-white border border-blue-200 rounded-lg shadow-sm hover:shadow-md transition-shadow cursor-pointer'
                                },
                                    e('div', { className: 'font-semibold text-gray-800' }, field),
                                    e('div', { className: 'text-xs text-gray-500 mt-1' }, 
                                        data.length > 0 ? `Sample: ${data[0][field]}` : 'No data'
                                    )
                                )
                            )
                        ),
                        e('p', { className: 'text-sm text-gray-600 mt-4' }, 
                            '💡 Click widget titles to edit them directly, use chart type dropdowns in headers, or click "Config" for advanced options.'
                        )
                    ),

                    // Quick Chart Type Selection Panel
                    e('div', { className: 'mb-6 p-4 bg-gradient-to-r from-green-50 to-teal-50 border border-green-200 rounded-lg' },
                        e('h3', { className: 'text-lg font-bold text-gray-800 mb-3 flex items-center' },
                            e('span', { className: 'mr-2' }, '📈'),
                            'Quick Chart Type Selection'
                        ),
                        e('div', { className: 'grid grid-cols-3 md:grid-cols-6 gap-3' },
                            Object.entries(CHART_TYPES).map(([key, value]) => {
                                const icons = {
                                    'LINE': '📈',
                                    'BAR': '📊', 
                                    'PIE': '🥧',
                                    'SCATTER': '🔵',
                                    'BUBBLE': '🫧',
                                    'HEATMAP': '🔥'
                                };
                                return e('button', {
                                    key: value,
                                    onClick: () => {
                                        console.log('Creating new widget with type:', value);
                                        const newWidget = {
                                            id: Math.max(...dashboardConfig.widgets.map(w => w.id)) + 1,
                                            type: value,
                                            title: `New ${key} Chart`,
                                            config: { xField: 'period', yField: 'revenue' },
                                            drillDown: []
                                        };
                                        setDashboardConfig(prev => ({
                                            ...prev,
                                            widgets: [...prev.widgets, newWidget]
                                        }));
                                    },
                                    className: 'p-3 bg-white border border-green-200 rounded-lg hover:bg-green-50 hover:border-green-300 transition-all text-center shadow-sm hover:shadow-md'
                                },
                                    e('div', { className: 'text-2xl mb-1' }, icons[key] || '📊'),
                                    e('div', { className: 'text-xs font-semibold text-gray-700' }, key)
                                );
                            })
                        )
                    ),
                    e('div', { 
                        className: `dashboard-grid grid-${dashboardConfig.gridColumns}-col`
                    },
                        dashboardConfig.widgets.map((widget, index) => {
                            const filteredData = getFilteredData(widget);
                            console.log(`Widget ${widget.id} (${widget.title}): filteredData length =`, filteredData.length);
                            console.log(`Widget ${widget.id} sample data:`, filteredData.slice(0, 2));
                            return e('div', { 
                                key: widget.id, 
                                className: 'widget-container bg-white rounded-lg shadow-lg hover:shadow-xl transition-shadow duration-300 relative',
                                draggable: true,
                                onDragStart: (e) => {
                                    setDraggedWidget({ widget, index });
                                    e.dataTransfer.effectAllowed = 'move';
                                    e.currentTarget.style.opacity = '0.5';
                                },
                                onDragEnd: (e) => {
                                    e.currentTarget.style.opacity = '1';
                                    setDraggedWidget(null);
                                },
                                onDragOver: (e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                },
                                onDrop: (e) => {
                                    e.preventDefault();
                                    if (draggedWidget && draggedWidget.widget.id !== widget.id) {
                                        reorderWidgets(draggedWidget.index, index);
                                    }
                                    setDraggedWidget(null);
                                }
                            },
                                // Widget Header
                                e('div', { className: 'widget-header p-4 border-b border-gray-200 flex justify-between items-center cursor-move' },
                                    e('div', { className: 'flex items-center space-x-3' },
                                        e('span', { className: 'text-gray-400 cursor-move' }, '⋮⋮'),
                                        e('div', { className: 'flex-1' },
                                            // Editable widget title
                                            e('input', {
                                                type: 'text',
                                                value: widget.title,
                                                onChange: (e) => {
                                                    console.log('Title updated to:', e.target.value);
                                                    updateWidgetTitle(widget.id, e.target.value);
                                                },
                                                className: 'bg-transparent border-none text-lg font-semibold text-gray-800 w-full focus:outline-none focus:bg-white focus:text-black focus:px-2 focus:py-1 focus:rounded',
                                                placeholder: 'Widget Title'
                                            }),
                                            // Chart type selector
                                            e('div', { className: 'flex items-center space-x-2 mt-2' },
                                                e('select', {
                                                    value: widget.type,
                                                    onChange: (e) => {
                                                        console.log('Chart type changed to:', e.target.value);
                                                        updateWidgetType(widget.id, e.target.value);
                                                    },
                                                    className: 'text-xs bg-white bg-opacity-20 border border-white border-opacity-30 rounded px-2 py-1 text-white font-semibold',
                                                    title: 'Chart Type'
                                                },
                                                    Object.entries(CHART_TYPES).map(([key, value]) => 
                                                        e('option', { key: value, value, style: { color: 'black' } }, 
                                                            `${key === 'LINE' ? '📈' : key === 'BAR' ? '📊' : key === 'PIE' ? '🥧' : key === 'SCATTER' ? '🔵' : key === 'BUBBLE' ? '🫧' : key === 'HEATMAP' ? '🔥' : '📉'} ${key}`
                                                        )
                                                    )
                                                ),
                                                e('select', {
                                                    value: widget.config.xField || '',
                                                    onChange: (e) => updateWidgetConfig(widget.id, { xField: e.target.value }),
                                                    className: 'text-xs bg-white bg-opacity-20 border border-white border-opacity-30 rounded px-2 py-1 text-white',
                                                    title: 'X-Axis Field'
                                                },
                                                    e('option', { value: '' }, 'X-Axis'),
                                                    getAvailableFields().map(field => 
                                                        e('option', { key: field, value: field, style: { color: 'black' } }, field)
                                                    )
                                                ),
                                                e('select', {
                                                    value: widget.config.yField || '',
                                                    onChange: (e) => updateWidgetConfig(widget.id, { yField: e.target.value }),
                                                    className: 'text-xs bg-white bg-opacity-20 border border-white border-opacity-30 rounded px-2 py-1 text-white',
                                                    title: 'Y-Axis Field'
                                                },
                                                    e('option', { value: '' }, 'Y-Axis'),
                                                    getAvailableFields().map(field => 
                                                        e('option', { key: field, value: field, style: { color: 'black' } }, field)
                                                    )
                                                )
                                            ),
                                            widget.drillDown.length > 0 && e('div', { className: 'drill-down-breadcrumb' },
                                                e('span', { className: 'text-sm text-gray-600' }, 'Filtered by: '),
                                                widget.drillDown.map((drill, index) => 
                                                    e('span', { key: index, className: 'text-sm' },
                                                        index > 0 && ' > ',
                                                        `${drill.field}: ${drill.value}`
                                                    )
                                                ),
                                                e('button', {
                                                    onClick: () => resetDrillDown(widget.id),
                                                    className: 'ml-2 text-sm text-blue-600 hover:text-blue-800'
                                                }, 'Reset')
                                            )
                                        )
                                    ),
                                    e('div', { className: 'flex items-center space-x-2' },
                                        e('button', {
                                            onClick: () => {
                                                console.log('Opening config modal for widget:', widget);
                                                setEditingWidget({ ...widget });
                                            },
                                            className: 'text-white hover:text-blue-200 p-2 rounded transition-colors bg-white bg-opacity-20 hover:bg-opacity-30',
                                            title: 'Advanced Configuration'
                                        }, '⚙️ Config'),
                                        e('button', {
                                            onClick: () => downloadChart(widget.id, widget.title),
                                            className: 'text-gray-600 hover:text-green-600 p-1 rounded transition-colors',
                                            title: 'Download Chart'
                                        }, '📥'),
                                        e('button', {
                                            onClick: () => removeWidget(widget.id),
                                            className: 'text-gray-600 hover:text-red-600 p-1 rounded transition-colors',
                                            title: 'Remove Widget'
                                        }, '×')
                                    )
                                ),

                                // Widget Content
                                e('div', { className: 'p-4' },
                                    filteredData.length > 0 ? 
                                        e(ChartRenderer, {
                                            data: filteredData,
                                            type: widget.type,
                                            config: widget.config,
                                            onDataPointClick: (dataPoint) => drillDown(widget.id, dataPoint),
                                            ref: chartRefs.current[widget.id]
                                        }) :
                                        e('div', { className: 'flex items-center justify-center h-64 text-gray-500' },
                                            e('div', { className: 'text-center' },
                                                e('div', { className: 'text-4xl mb-2' }, '📊'),
                                                e('p', null, 'No data available for current filter')
                                            )
                                        )
                                )
                            );
                        })
                    )
                ),

                // AI Insights Section
                data.length > 0 && e('div', { className: 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-8' },
                    e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                        e('div', { className: 'flex items-center justify-between mb-4' },
                            e('h2', { className: 'text-xl font-bold text-gray-800' }, '🤖 AI-Generated Insights'),
                            e('div', { className: 'flex items-center gap-2' },
                                isProcessing && e('div', { className: 'loading-spinner w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full' }),
                                e('button', {
                                    onClick: () => processData(data),
                                    className: 'px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 transition-colors',
                                    disabled: isProcessing
                                }, isProcessing ? 'Processing...' : 'Refresh Insights')
                            )
                        ),
                        isProcessing ? 
                            e('div', { className: 'text-center py-8' },
                                e('div', { className: 'loading-spinner w-8 h-8 border-3 border-blue-500 border-t-transparent rounded-full mx-auto mb-4' }),
                                e('h3', { className: 'text-lg font-semibold mt-2' }, 'Generating AI Insights...'),
                                e('p', { className: 'text-gray-600' }, 'Our AI is analyzing your data to provide actionable insights'),
                                LLMService.getApiKey() ? 
                                    e('p', { className: 'text-green-600 text-sm mt-2' }, '✅ Using OpenAI GPT for enhanced insights') :
                                    e('p', { className: 'text-orange-600 text-sm mt-2' }, '⚠️ Using rule-based insights (configure OpenAI key for enhanced AI)')
                            ) :
                            insights.length > 0 ? 
                                e('div', null,
                                    LLMService.getApiKey() ? 
                                        e('div', { className: 'mb-4 p-3 bg-green-50 border border-green-200 rounded-lg' },
                                            e('p', { className: 'text-green-800 text-sm' }, '✨ Enhanced AI insights powered by OpenAI GPT')
                                        ) :
                                        e('div', { className: 'mb-4 p-3 bg-orange-50 border border-orange-200 rounded-lg' },
                                            e('p', { className: 'text-orange-800 text-sm' }, '🔧 Using rule-based insights. Configure OpenAI API key for enhanced AI analysis.')
                                        ),
                                    e('div', { className: 'space-y-4' },
                                        insights.map((insight, index) => 
                                            e('div', { 
                                                key: index, 
                                                className: 'p-4 bg-blue-50 border-l-4 border-blue-500 rounded-r-lg hover:bg-blue-100 transition-colors'
                                            },
                                                e('div', { className: 'flex items-start' },
                                                    e('span', { className: 'text-2xl mr-3 flex-shrink-0' }, '💡'),
                                                    e('div', { className: 'flex-1' },
                                                        e('h4', { className: 'font-semibold text-blue-800 mb-1' }, insight.title),
                                                        e('p', { className: 'text-blue-700' }, insight.description),
                                                        insight.confidence && e('div', { className: 'mt-2' },
                                                            e('span', { className: 'text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded' },
                                                                `Confidence: ${insight.confidence}%`
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                ) :
                                e('div', { className: 'text-center py-8 text-gray-500' },
                                    e('div', { className: 'text-4xl mb-4' }, '🤖'),
                                    e('h3', { className: 'text-lg font-semibold mb-2' }, 'AI Insights Ready'),
                                    e('p', { className: 'mb-4' }, 'Upload data to receive AI-powered analytics and recommendations'),
                                    !LLMService.getApiKey() && e('div', { className: 'mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg' },
                                        e('p', { className: 'text-yellow-800 text-sm' }, '💡 Configure your OpenAI API key in the settings above for enhanced AI insights')
                                    )
                                )
                    )
                )
            );
        };

        // ====================== MAIN APPLICATION ======================
        const AnalyticsApp = () => {
            const { data, insights, isProcessing, processData, setData } = useAnalyticsData();
            const [activeChart, setActiveChart] = useState(CHART_TYPES.LINE);
            const [chartConfig, setChartConfig] = useState({
                xField: 'period',
                yField: 'revenue',
                color: '#3b82f6'
            });
            const [isGeneratingReport, setIsGeneratingReport] = useState(false);
            
            const chartRefs = [useRef(null), useRef(null), useRef(null), useRef(null), useRef(null)];

            useEffect(() => {
                if (data.length === 0) {
                    const sampleData = DataProcessor.generateSampleData(DATA_TYPES.SALES, 12);
                    processData(sampleData);
                }
            }, [data.length, processData]);

            const handleDataUpload = useCallback((uploadedData) => {
                processData(uploadedData);
            }, [processData]);

            const generateComprehensiveReport = useCallback(async () => {
                setIsGeneratingReport(true);
                try {
                    const pdf = await ReportGenerator.generateComprehensiveReport(
                        data, 
                        insights, 
                        chartRefs
                    );
                    
                    if (pdf) {
                        // Success - save the PDF
                        pdf.save(`analytics-report-${new Date().toISOString().split('T')[0]}.pdf`);
                        
                        // Show success message briefly
                        const successOverlay = document.createElement('div');
                        successOverlay.className = 'export-overlay';
                        successOverlay.innerHTML = `
                            <div style="background: green; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;">✓</div>
                            <h2 style="margin: 20px 0; color: white;">Report Generated Successfully!</h2>
                            <p>Your PDF report has been downloaded.</p>
                        `;
                        document.body.appendChild(successOverlay);
                        
                        setTimeout(() => {
                            document.body.removeChild(successOverlay);
                        }, 2000);
                    }
                } catch (error) {
                    console.error('Report generation failed:', error);
                    alert('Failed to generate report. Please try again. Error: ' + error.message);
                } finally {
                    setIsGeneratingReport(false);
                }
            }, [data, insights, chartRefs]);

            if (data.length === 0 && !isProcessing) {
                return e('div', { className: 'min-h-screen bg-gray-100 p-6' },
                    e('div', { className: 'max-w-4xl mx-auto' },
                        e('div', { className: 'text-center mb-8' },
                            e('h1', { className: 'text-4xl font-bold text-gray-800 mb-4' }, 'Enterprise Analytics Dashboard'),
                            e('p', { className: 'text-xl text-gray-600' }, 'Upload your data to get started with advanced analytics')
                        ),
                        e('div', { className: 'grid md:grid-cols-2 gap-8' },
                            e(FileUploader, { onDataUpload: handleDataUpload }),
                            e(TemplateDownloader, null)
                        )
                    )
                );
            }

            return e('div', { className: 'min-h-screen bg-gray-100' },
                // Header
                e('header', { className: 'gradient-bg text-white p-6 shadow-lg' },
                    e('div', { className: 'max-w-7xl mx-auto' },
                        e('div', { className: 'flex justify-between items-center' },
                            e('div', null,
                                e('h1', { className: 'text-3xl font-bold mb-2' }, 'Enterprise Analytics Dashboard'),
                                e('p', { className: 'text-blue-100' }, 'Advanced Business Intelligence & Predictive Analytics')
                            ),
                            e('div', { className: 'flex gap-4' },
                                e('button', {
                                    className: 'px-4 py-2 bg-white bg-opacity-20 text-white rounded-lg hover:bg-opacity-30 transition-colors',
                                    onClick: () => {
                                        console.log('Clearing data and generating new sample data...');
                                        localStorage.removeItem('analyticsData');
                                        setData([]);
                                        window.location.reload(); // Force page reload to regenerate data
                                    }
                                }, 'New Analysis'),
                                e('button', {
                                    className: 'px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors',
                                    onClick: () => {
                                        console.log('=== DEBUG DATA ===');
                                        console.log('Current data length:', data.length);
                                        console.log('Current data:', data);
                                        console.log('localStorage data:', localStorage.getItem('analyticsData'));
                                        
                                        // Force generate new data
                                        const freshData = DataProcessor.generateSampleData(DATA_TYPES.SALES, 12);
                                        const enhancedData = freshData.map((item, index) => ({
                                            ...item,
                                            category: ['Electronics', 'Clothing', 'Food', 'Books'][index % 4],
                                            region: ['North', 'South', 'East', 'West'][index % 4]
                                        }));
                                        console.log('Fresh generated data:', enhancedData);
                                        
                                        setData(enhancedData);
                                        console.log('Data set, should trigger re-render');
                                    }
                                }, 'Debug Data'),
                                e('button', {
                                    className: 'px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors',
                                    onClick: generateComprehensiveReport,
                                    disabled: isGeneratingReport
                                }, isGeneratingReport ? 'Generating...' : 'Export Report')
                            )
                        )
                    )
                ),

                // Main Content
                e('main', { className: 'max-w-7xl mx-auto p-6' },
                    // Metrics Dashboard
                    e(MetricsDashboard, { data }),

                    // LLM Configuration
                    e(LLMConfigCard),

                    // AI-Generated Insights Section (always show)
                    e('div', { className: 'mb-8' },
                        e('h2', { className: 'text-2xl font-bold text-gray-800 mb-6 flex items-center' },
                            e('span', { className: 'mr-3' }, '🤖'),
                            'AI-Generated Insights',
                            e('span', { className: 'ml-2 text-sm font-normal text-gray-500' }, 
                                `(${insights.length} insights generated)`
                            )
                        ),
                        insights.length > 0 ? e('div', { className: 'grid md:grid-cols-2 lg:grid-cols-3 gap-6' },
                            insights.slice(0, 6).map((insight, index) =>
                                e(InsightCard, { key: insight.id, insight, index })
                            )
                        ) : e('div', { className: 'bg-white rounded-lg shadow-lg p-6 text-center' },
                            e('div', { className: 'text-gray-500 mb-4' },
                                e('span', { className: 'text-4xl' }, '🔄'),
                                e('h3', { className: 'text-lg font-semibold mt-2' }, 'Generating AI Insights...'),
                                e('p', { className: 'text-sm mt-2' }, 'Processing your data to generate intelligent insights and recommendations.'),
                                isProcessing && e('div', { className: 'mt-4' },
                                    e('div', { className: 'inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600' })
                                )
                            )
                        )
                    ),

                    // Trend Predictions Section
                    data.length > 2 && e('div', { className: 'mb-8' },
                        e('h2', { className: 'text-2xl font-bold text-gray-800 mb-6 flex items-center' },
                            e('span', { className: 'mr-3' }, '📈'),
                            'Trend Predictions & Forecasting'
                        ),
                        e('div', { className: 'grid md:grid-cols-2 gap-6' },
                            e(TrendPredictionsCard, { data, insights }),
                            e(ForecastingCard, { data })
                        )
                    ),

                    // Chart Controls and Visualization
                    e(ChartControls, {
                        activeChart,
                        onChartChange: setActiveChart,
                        chartConfig,
                        onConfigChange: setChartConfig
                    }),

                    // Chart Display
                    e('div', { className: 'bg-white rounded-lg shadow-lg p-6 mb-8' },
                        e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Data Visualization'),
                        e(ChartRenderer, {
                            ref: chartRefs[0],
                            data,
                            type: activeChart,
                            config: chartConfig
                        })
                    ),

                    // Additional Charts for Report
                    data.length > 0 && e('div', { className: 'grid md:grid-cols-2 lg:grid-cols-2 gap-6 mb-8' },
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Trend Analysis'),
                            e('div', { className: 'chart-container' },
                                e(ChartRenderer, {
                                    ref: chartRefs[1],
                                    data,
                                    type: CHART_TYPES.AREA,
                                    config: { ...chartConfig, color: '#10b981' }
                                })
                            )
                        ),
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Correlation View'),
                            e('div', { className: 'chart-container' },
                                e(ChartRenderer, {
                                    ref: chartRefs[2],
                                    data,
                                    type: CHART_TYPES.SCATTER,
                                    config: { xField: 'users', yField: 'revenue', color: '#f59e0b' }
                                })
                            )
                        ),
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Revenue Distribution (Pie Chart)'),
                            e('div', { className: 'chart-container' },
                                e(ChartRenderer, {
                                    ref: chartRefs[3],
                                    data,
                                    type: CHART_TYPES.PIE,
                                    config: { xField: 'period', yField: 'revenue' }
                                })
                            )
                        ),
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'User Distribution (Donut Chart)'),
                            e('div', { className: 'chart-container' },
                                e(ChartRenderer, {
                                    ref: chartRefs[4],
                                    data,
                                    type: CHART_TYPES.DONUT,
                                    config: { xField: 'period', yField: 'users' }
                                })
                            )
                        )
                    ),

                    // Add Widget Button
                    e('div', { className: 'text-center mb-8' },
                        e('button', {
                            onClick: addWidget,
                            className: 'px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors shadow-lg'
                        }, '+ Add New Widget')
                    ),

                    // Data Upload Section
                    e('div', { className: 'grid md:grid-cols-2 gap-8' },
                        e('div', { className: 'bg-white rounded-lg shadow-lg p-6' },
                            e('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 'Upload New Data'),
                            e(FileUploader, { onDataUpload: handleDataUpload })
                        ),
                        e(TemplateDownloader, null)
                    )
                ),

                // Widget Configuration Modal
                e(WidgetConfigModal)
            );
        };

        // Wrap main app with HOCs
        const EnhancedConfigurableDashboard = withErrorBoundary(withLoading(ConfigurableDashboard));

        // Render Application
        ReactDOM.render(
            e(EnhancedConfigurableDashboard, { isLoading: false }),
            document.getElementById('root')
        );
    </script>
</body>
</html>
